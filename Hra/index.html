<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Svecena Voda vs Certi</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #000; font-family: 'Segoe UI', Arial, sans-serif; }
canvas { display: block; cursor: none; outline: none; }
#ui {
  position: absolute; top: 0; left: 0; width: 100%; padding: 10px 20px;
  display: flex; justify-content: space-between; align-items: center;
  pointer-events: none; z-index: 10;
}
#ui > div { pointer-events: auto; }
.hud-text {
  color: #ffd700; font-size: 20px; font-weight: bold;
  text-shadow: 2px 2px 4px #000, 0 0 10px rgba(255,215,0,0.5);
}
#startScreen, #gameOverScreen {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  background: rgba(0,0,0,0.85); z-index: 20; color: #fff;
}
#startScreen h1, #gameOverScreen h1 {
  font-size: 48px; color: #ffd700; margin-bottom: 10px;
  text-shadow: 0 0 20px rgba(255,215,0,0.6);
}
#startScreen p, #gameOverScreen p {
  font-size: 18px; color: #ccc; margin-bottom: 30px; text-align: center; line-height: 1.6;
}
#startContent {
  display: flex; align-items: flex-start; justify-content: center;
  gap: 40px; width: 90%; max-width: 1300px; margin-bottom: 24px;
}
.info-panel {
  flex: 1; max-width: 380px; background: rgba(255,215,0,0.06);
  border: 1px solid rgba(255,215,0,0.25); border-radius: 12px;
  padding: 16px 18px; text-align: left;
}
.info-panel h2 {
  font-size: 22px; color: #ffd700; margin-bottom: 12px; text-align: center;
  text-shadow: 0 0 10px rgba(255,215,0,0.4);
}
.info-item {
  margin-bottom: 10px; padding: 8px 10px; border-radius: 6px;
  background: rgba(255,255,255,0.04); border-left: 3px solid rgba(255,215,0,0.4);
}
.info-item .item-name {
  font-size: 15px; font-weight: bold; color: #ffd700; margin-bottom: 3px;
}
.info-item .item-key {
  display: inline-block; background: rgba(255,255,255,0.12); color: #ddd;
  padding: 1px 7px; border-radius: 4px; font-size: 12px; margin-left: 6px;
  border: 1px solid rgba(255,255,255,0.2);
}
.info-item .item-stats {
  font-size: 13px; color: #aaa; line-height: 1.5;
}
.info-item .item-stats span { color: #cde; }
#startCenter {
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  min-width: 300px;
}
.btn {
  padding: 15px 40px; font-size: 22px; background: linear-gradient(180deg, #ffd700, #b8860b);
  border: 2px solid #ffd700; color: #1a0a00; font-weight: bold; cursor: pointer;
  border-radius: 8px; transition: transform 0.2s, box-shadow 0.2s;
}
.btn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(255,215,0,0.6); }
#finalScore { font-size: 36px; color: #ffd700; margin: 10px 0 20px; }
#gameOverTitle.victory {
  color: #ffd700;
  text-shadow: 0 0 30px rgba(255,215,0,0.8), 0 0 60px rgba(255,215,0,0.4);
  animation: victoryPulse 1.5s ease-in-out infinite;
}
@keyframes victoryPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="ui">
  <div class="hud-text" id="scoreDisplay">Skore: 0</div>
  <div class="hud-text" id="waveDisplay">Vlna: 1</div>
  <div class="hud-text" id="livesDisplay"></div>
</div>

<div id="startScreen">
  <h1>Svecena voda vs Certi</h1>
  <p>Branis kostel pred letajicimi certy! Strilej kliknutim.<br>
  Prepinej zbrane klavesami nebo koleckem mysi. Dobij mezernikem.</p>

  <div id="startContent">
    <!-- Zbrane - leva strana -->
    <div class="info-panel">
      <h2>Zbrane</h2>
      <div class="info-item">
        <div class="item-name">Svecena voda <span class="item-key">1</span></div>
        <div class="item-stats">
          Dmg: <span>10</span> | Rychlost: <span>10</span> | Cena: <span>10%</span><br>
          Zakladni zbran, hazi svecenu vodu
        </div>
      </div>
      <div class="info-item">
        <div class="item-name">Pistolka <span class="item-key">2</span></div>
        <div class="item-stats">
          Dmg: <span>5</span> | Rychlost: <span>20</span> | Zasobnik: <span>20</span><br>
          Dobiti: <span>40%</span> vody | Strelba nestoji vodu
        </div>
      </div>
      <div class="info-item">
        <div class="item-name">Kropenka <span class="item-key">3</span></div>
        <div class="item-stats">
          Dmg: <span>4</span> | Rychlost: <span>16</span> | Zasobnik: <span>80</span><br>
          Dobiti: <span>60%</span> vody | Automaticka palba
        </div>
      </div>
      <div class="info-item">
        <div class="item-name">Sprej <span class="item-key">Q</span></div>
        <div class="item-stats">
          Dmg: <span>1&times;16</span> | Cena: <span>20%</span><br>
          Brokovnice - 16 kapek v sirsi 60&deg;
        </div>
      </div>
      <div class="info-item">
        <div class="item-name">Svaty proud <span class="item-key">W</span></div>
        <div class="item-stats">
          Dmg: <span>10</span> | Cena: <span>50%</span><br>
          Paprsek prochazi vsemi neprateli
        </div>
      </div>
      <div class="info-item">
        <div class="item-name">Balonek <span class="item-key">E</span></div>
        <div class="item-stats">
          Dmg: <span>20</span> | Cena: <span>30%</span><br>
          Pomaly balonek s velkou explozi (160px)
        </div>
      </div>
    </div>

    <!-- Stred - navod + tlacitko -->
    <div id="startCenter">
      <button class="btn" id="startBtn">Hrat</button>
    </div>

    <!-- Modlidby - prava strana -->
    <div class="info-panel">
      <h2>Modlitby</h2>
      <div class="info-item" style="border-left-color: #50c8ff;">
        <div class="item-name" style="color:#50c8ff;">Zpomaleni <span class="item-key">Ctrl</span></div>
        <div class="item-stats">
          Cena: <span>50%</span> vody | Trvani: <span>5s</span><br>
          Cooldown: <span>10s</span><br>
          Zpomali vsechny nepratele o 40%
        </div>
      </div>
      <div class="info-item" style="border-left-color: #ffee44;">
        <div class="item-name" style="color:#ffee44;">Blesky <span class="item-key">Shift</span></div>
        <div class="item-stats">
          Cena: <span>70%</span> vody | Trvani: <span>15s</span><br>
          Cooldown: <span>10s</span><br>
          Automaticky bije blesky na nepratele<br>
          s &le;6 HP (kazdy blesk dela 6 dmg)
        </div>
      </div>
    </div>
  </div>
</div>

<div id="gameOverScreen" style="display:none;">
  <h1 id="gameOverTitle">Konec hry!</h1>
  <p id="gameOverText">Certi ovladli kostel...</p>
  <div id="finalScore">0</div>
  <button class="btn" id="restartBtn">Hrat znovu</button>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Game state
let score = 0;
let lives = 5;
let wave = 1;
let devils = [];
let splashes = [];
let holyWaters = [];
let particles = [];
let stars = [];
let gameRunning = false;
let devilsKilledInWave = 0;
let devilsPerWave = 5;
let spawnTimer = 0;
let spawnInterval = 120;
let devilsSpawnedInWave = 0;
let crossGlow = 0;
let gameWon = false;

// Enemy type definitions
const enemyTypes = {
  cert:  { minHp: 10, maxHp: 10, minSpeed: 1.0, maxSpeed: 2.0, minSize: 20, maxSize: 30, scoreMult: 10 },
  demon: { minHp: 20, maxHp: 20, minSpeed: 0.5, maxSpeed: 1.0, minSize: 30, maxSize: 40, scoreMult: 15 },
  dabel: { minHp: 40, maxHp: 40, minSpeed: 0.75, maxSpeed: 1.5, minSize: 40, maxSize: 50, scoreMult: 25 },
};

// Wave definitions (10 waves) - weights: [cert, demon, dabel]
const waveConfig = [
  { count: 8,  spawnInterval: 120, name: 'Prvni horda',      weights: [1.0, 0.0, 0.0] },
  { count: 10, spawnInterval: 110, name: 'Posily z pekla',   weights: [0.8, 0.2, 0.0] },
  { count: 12, spawnInterval: 100, name: 'Tuzsi korist',     weights: [0.6, 0.4, 0.0] },
  { count: 14, spawnInterval: 90,  name: 'Pekelny pruval',   weights: [0.4, 0.6, 0.0] },
  { count: 16, spawnInterval: 80,  name: 'Certuv regiment',  weights: [0.2, 0.7, 0.1] },
  { count: 18, spawnInterval: 70,  name: 'Temnota houstne',  weights: [0.1, 0.8, 0.1] },
  { count: 20, spawnInterval: 60,  name: 'Nebeska zkouska',  weights: [0.1, 0.7, 0.2] },
  { count: 22, spawnInterval: 50,  name: 'Pekelna ofenziva', weights: [0.0, 0.6, 0.4] },
  { count: 24, spawnInterval: 40,  name: 'Satanuv hnev',     weights: [0.0, 0.4, 0.6] },
  { count: 36, spawnInterval: 30,  name: 'Finalni bitva!',   weights: [0.0, 0.2, 0.8] },
];
const totalWaves = waveConfig.length;

// Pick random enemy type based on wave weights
function pickEnemyType(waveIndex) {
  const w = waveConfig[Math.min(waveIndex, totalWaves - 1)].weights;
  const r = Math.random();
  if (r < w[0]) return 'cert';
  if (r < w[0] + w[1]) return 'demon';
  return 'dabel';
}

// Wave announcement banner
let waveBanner = '';
let waveBannerTimer = 0;
const waveBannerDuration = 120; // 2 seconds
let shakeTimer = 0;
let shakeIntensity = 0;

// Water tank
const waterMax = 100;
let water = waterMax;
const waterRefillRate = 0.05; // per frame
let waterFlashTimer = 0; // flash red when empty

// Weapons system
const weapons = [
  { name: 'Svecena voda', key: '1', waterCost: 10, damage: 10, speed: 10, size: 10, color: '#7ec8f0', trailColor: 'rgba(100,180,255,', gravity: 0.04, piercing: false },
  { name: 'Pistolka', key: '2', waterCost: 0, damage: 5, speed: 20, size: 6, color: '#b0e0ff', trailColor: 'rgba(170,220,255,', gravity: 0.01, piercing: false },
  { name: 'Kropenka', key: '3', waterCost: 0, damage: 4, speed: 16, size: 4, color: '#90d0f0', gravity: 0.02, piercing: false, machineGun: true, fireRate: 4 },
  { name: 'Sprej', key: 'Q', waterCost: 20, damage: 5, speed: 8, size: 1, dropCount: 30, spreadAngle: 60, color: '#a0d8ef', gravity: 0.08, piercing: false },
  { name: 'Svaty proud', key: 'W', waterCost: 50, damage: 40, beamWidth: 32, color: '#50c8ff', piercing: true },
  { name: 'Balonek', key: 'E', waterCost: 30, damage: 20, speed: 2, size: 20, color: '#4da6ff', explosionRadius: 160 }
];
let currentWeapon = 0;
let pistolBullets = [];
let sprayDrops = [];
let weaponSwitchTimer = 0; // for HUD animation

// Pistol magazine
const pistolMagMax = 20;
let pistolAmmo = pistolMagMax;
let pistolReloading = false;
let pistolReloadTimer = 0;
const pistolReloadTime = 90; // frames (~1.5s at 60fps)
const pistolReloadWaterCost = 40;

// Beam weapon state (single-shot beam flash)
let beamFlash = null; // { x1, y1, x2, y2, timer, maxTimer }
let mouseHeld = false;

// Kropenka (machine gun) state
let kropenkaTimer = 0;
let kropenkaBullets = [];

// Balloon state
let balloons = [];
let balloonExplosions = []; // { x, y, radius, timer, maxTimer }
const kropenkaMagMax = 80;
let kropenkaAmmo = kropenkaMagMax;
let kropenkaReloading = false;
let kropenkaReloadTimer = 0;
const kropenkaReloadTime = 120; // frames (~2s at 60fps)
const kropenkaReloadWaterCost = 60;

// Prayer (ability) system
const prayers = [
  { name: 'Zpomaleni', key: 'Ctrl', waterCost: 50, duration: 300, cooldown: 600 },
  { name: 'Blesky', key: 'Shift', waterCost: 70, duration: 900, cooldown: 600, boltDamage: 6, boltMaxHp: 6, boltInterval: 20 }
];
let lightningBolts = []; // { x1, y1, x2, y2, timer, segments: [{x,y}] }
let prayerStates = [];
function initPrayerStates() {
  prayerStates = prayers.map(() => ({ active: false, timer: 0, cooldownTimer: 0 }));
}
initPrayerStates();

function activatePrayer(index) {
  const p = prayers[index];
  const ps = prayerStates[index];
  if (ps.active || ps.cooldownTimer > 0) return false;
  if (water < p.waterCost) { waterFlashTimer = 0; return false; }
  water -= p.waterCost;
  ps.active = true;
  ps.timer = p.duration;
  return true;
}

let lightningBoltTimer = 0;

function updatePrayers() {
  for (let i = 0; i < prayerStates.length; i++) {
    const ps = prayerStates[i];
    if (ps.active) {
      ps.timer--;
      if (ps.timer <= 0) {
        ps.active = false;
        ps.cooldownTimer = prayers[i].cooldown;
      }
    } else if (ps.cooldownTimer > 0) {
      ps.cooldownTimer--;
    }
  }

  // Lightning bolt logic (prayer index 1)
  if (prayerStates[1] && prayerStates[1].active) {
    lightningBoltTimer++;
    if (lightningBoltTimer >= prayers[1].boltInterval) {
      lightningBoltTimer = 0;
      // Find eligible target (hp <= boltMaxHp, alive)
      const targets = devils.filter(d => d.alive && d.hp <= prayers[1].boltMaxHp);
      if (targets.length > 0) {
        const target = targets[Math.floor(Math.random() * targets.length)];
        // Create lightning bolt visual
        const segments = [];
        const startX = target.x + (Math.random() - 0.5) * 40;
        const startY = Math.max(0, target.y - 300 - Math.random() * 100);
        let cx = startX, cy = startY;
        const steps = 8 + Math.floor(Math.random() * 5);
        for (let s = 0; s <= steps; s++) {
          const t = s / steps;
          const tx = startX + (target.x - startX) * t + (Math.random() - 0.5) * 30 * (1 - t);
          const ty = startY + (target.y - startY) * t;
          segments.push({ x: tx, y: ty });
        }
        segments[segments.length - 1] = { x: target.x, y: target.y };
        lightningBolts.push({ segments, timer: 12 });
        // Deal damage
        target.hit(prayers[1].boltDamage);
        updateScore();
        // Screen shake
        shakeTimer = 4;
        shakeIntensity = 3;
        // Spark particles
        for (let p = 0; p < 6; p++) {
          particles.push({
            x: target.x, y: target.y,
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            life: 10 + Math.random() * 10,
            maxLife: 20,
            color: Math.random() < 0.5 ? '#fff' : '#ffee44',
            size: 2 + Math.random() * 2
          });
        }
      }
    }
  } else {
    lightningBoltTimer = 0;
  }

  // Update lightning bolt visuals
  for (let i = lightningBolts.length - 1; i >= 0; i--) {
    lightningBolts[i].timer--;
    if (lightningBolts[i].timer <= 0) lightningBolts.splice(i, 1);
  }
}

function drawLightningBolts() {
  for (const bolt of lightningBolts) {
    const alpha = bolt.timer / 12;
    // Main bolt
    ctx.strokeStyle = `rgba(255,255,100,${alpha})`;
    ctx.lineWidth = 3;
    ctx.shadowColor = '#ffee44';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.moveTo(bolt.segments[0].x, bolt.segments[0].y);
    for (let s = 1; s < bolt.segments.length; s++) {
      ctx.lineTo(bolt.segments[s].x, bolt.segments[s].y);
    }
    ctx.stroke();
    // Inner bright core
    ctx.strokeStyle = `rgba(255,255,255,${alpha * 0.8})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(bolt.segments[0].x, bolt.segments[0].y);
    for (let s = 1; s < bolt.segments.length; s++) {
      ctx.lineTo(bolt.segments[s].x, bolt.segments[s].y);
    }
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
}

// Input tracking
let mouseX = 0;
let mouseY = 0;
const keysDown = {};
const keysJustPressed = {};

// Angel system
let angels = [];
let angelSpawnCooldown = 0;
const angelSpawnCooldownMax = 300; // min frames between angel spawns

// Generate stars
function generateStars() {
  stars = [];
  for (let i = 0; i < 100; i++) {
    stars.push({
      x: Math.random() * W,
      y: Math.random() * H * 0.5,
      size: Math.random() * 2 + 0.5,
      twinkle: Math.random() * Math.PI * 2,
      speed: Math.random() * 0.02 + 0.01
    });
  }
}
generateStars();

// Church drawing
function drawChurch() {
  const cx = W / 2;
  const groundY = H - 60;

  // Ground
  const grd = ctx.createLinearGradient(0, groundY - 20, 0, H);
  grd.addColorStop(0, '#2d5016');
  grd.addColorStop(1, '#1a3009');
  ctx.fillStyle = grd;
  ctx.fillRect(0, groundY - 20, W, H - groundY + 20);

  // Church body
  const bw = 220, bh = 200;
  const bx = cx - bw / 2, by = groundY - bh;

  const wallGrd = ctx.createLinearGradient(bx, by, bx + bw, by);
  wallGrd.addColorStop(0, '#8B7355');
  wallGrd.addColorStop(0.5, '#A0896C');
  wallGrd.addColorStop(1, '#7A6548');
  ctx.fillStyle = wallGrd;
  ctx.fillRect(bx, by, bw, bh);

  // Stone lines
  ctx.strokeStyle = 'rgba(0,0,0,0.15)';
  ctx.lineWidth = 1;
  for (let row = 0; row < 8; row++) {
    const ry = by + row * 25;
    ctx.beginPath(); ctx.moveTo(bx, ry); ctx.lineTo(bx + bw, ry); ctx.stroke();
    const offset = row % 2 === 0 ? 0 : 35;
    for (let col = offset; col < bw; col += 70) {
      ctx.beginPath(); ctx.moveTo(bx + col, ry); ctx.lineTo(bx + col, ry + 25); ctx.stroke();
    }
  }

  // Roof
  ctx.fillStyle = '#4a3728';
  ctx.beginPath();
  ctx.moveTo(bx - 20, by);
  ctx.lineTo(cx, by - 100);
  ctx.lineTo(bx + bw + 20, by);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = '#3a2718';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Tower
  const tw = 60, th = 140;
  const tx = cx - tw / 2, ty = by - 100 - th + 40;
  ctx.fillStyle = '#9B8B75';
  ctx.fillRect(tx, ty, tw, th);

  // Tower roof
  ctx.fillStyle = '#4a3728';
  ctx.beginPath();
  ctx.moveTo(tx - 10, ty);
  ctx.lineTo(cx, ty - 60);
  ctx.lineTo(tx + tw + 10, ty);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Cross on top
  crossGlow = (crossGlow + 0.03) % (Math.PI * 2);
  const glowAlpha = 0.3 + Math.sin(crossGlow) * 0.2;
  ctx.shadowColor = '#ffd700';
  ctx.shadowBlur = 15 + Math.sin(crossGlow) * 10;
  ctx.strokeStyle = '#ffd700';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(cx, ty - 60); ctx.lineTo(cx, ty - 90);
  ctx.moveTo(cx - 12, ty - 78); ctx.lineTo(cx + 12, ty - 78);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Glow circle around cross
  ctx.beginPath();
  ctx.arc(cx, ty - 75, 25, 0, Math.PI * 2);
  ctx.fillStyle = `rgba(255,215,0,${glowAlpha * 0.3})`;
  ctx.fill();

  // Window - rose window
  ctx.beginPath();
  ctx.arc(cx, by + 50, 30, 0, Math.PI * 2);
  ctx.fillStyle = '#1a0a30';
  ctx.fill();
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 3;
  ctx.stroke();
  // Rose window spokes
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2;
    ctx.beginPath();
    ctx.moveTo(cx, by + 50);
    ctx.lineTo(cx + Math.cos(angle) * 28, by + 50 + Math.sin(angle) * 28);
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }
  // Inner glow
  const rGrd = ctx.createRadialGradient(cx, by + 50, 0, cx, by + 50, 28);
  rGrd.addColorStop(0, 'rgba(100,50,150,0.4)');
  rGrd.addColorStop(0.5, 'rgba(50,20,100,0.2)');
  rGrd.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = rGrd;
  ctx.beginPath();
  ctx.arc(cx, by + 50, 28, 0, Math.PI * 2);
  ctx.fill();

  // Side windows
  for (let i = -1; i <= 1; i += 2) {
    const wx = cx + i * 65;
    ctx.fillStyle = '#1a0a30';
    ctx.fillRect(wx - 12, by + 80, 24, 50);
    ctx.beginPath();
    ctx.arc(wx, by + 80, 12, Math.PI, 0);
    ctx.fill();
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.strokeRect(wx - 12, by + 80, 24, 50);
    ctx.beginPath();
    ctx.arc(wx, by + 80, 12, Math.PI, 0);
    ctx.stroke();
    // Yellow glow from inside
    const wGrd = ctx.createRadialGradient(wx, by + 100, 0, wx, by + 100, 20);
    wGrd.addColorStop(0, 'rgba(255,200,50,0.3)');
    wGrd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = wGrd;
    ctx.fillRect(wx - 12, by + 80, 24, 50);
  }

  // Door
  ctx.fillStyle = '#3a2000';
  ctx.fillRect(cx - 22, by + 150, 44, 50);
  ctx.beginPath();
  ctx.arc(cx, by + 150, 22, Math.PI, 0);
  ctx.fill();
  ctx.strokeStyle = '#2a1500';
  ctx.lineWidth = 2;
  ctx.strokeRect(cx - 22, by + 150, 44, 50);
  ctx.beginPath();
  ctx.arc(cx, by + 150, 22, Math.PI, 0);
  ctx.stroke();

  // Door handle
  ctx.beginPath();
  ctx.arc(cx + 10, by + 175, 3, 0, Math.PI * 2);
  ctx.fillStyle = '#b8860b';
  ctx.fill();
}

// Sky gradient
function drawSky() {
  const grd = ctx.createLinearGradient(0, 0, 0, H);
  grd.addColorStop(0, '#0a0020');
  grd.addColorStop(0.4, '#1a0040');
  grd.addColorStop(0.7, '#2a1050');
  grd.addColorStop(1, '#150030');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, W, H);

  // Moon
  ctx.beginPath();
  ctx.arc(W * 0.8, H * 0.12, 40, 0, Math.PI * 2);
  ctx.fillStyle = '#ffe8b0';
  ctx.shadowColor = '#ffe8b0';
  ctx.shadowBlur = 40;
  ctx.fill();
  ctx.shadowBlur = 0;
  // Moon crater
  ctx.beginPath();
  ctx.arc(W * 0.8 - 10, H * 0.12 - 5, 35, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(10,0,30,0.15)';
  ctx.fill();

  // Stars
  stars.forEach(s => {
    s.twinkle += s.speed;
    const alpha = 0.4 + Math.sin(s.twinkle) * 0.4;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,220,${alpha})`;
    ctx.fill();
  });
}

// Devil class
class Devil {
  constructor(type) {
    this.type = type || 'cert';
    const et = enemyTypes[this.type];
    this.size = et.minSize + Math.random() * (et.maxSize - et.minSize);
    this.hp = et.minHp + Math.floor(Math.random() * (et.maxHp - et.minHp + 1));
    this.maxHp = this.hp;
    this.speed = et.minSpeed + Math.random() * (et.maxSpeed - et.minSpeed);
    this.scoreMult = et.scoreMult;

    // Spawn from sides or top
    const side = Math.random();
    if (side < 0.4) {
      this.x = -this.size;
      this.y = Math.random() * H * 0.5 + 50;
    } else if (side < 0.8) {
      this.x = W + this.size;
      this.y = Math.random() * H * 0.5 + 50;
    } else {
      this.x = Math.random() * W;
      this.y = -this.size;
    }

    this.targetX = W / 2 + (Math.random() - 0.5) * 200;
    this.targetY = H - 260 + Math.random() * 80;
    this.wingAngle = 0;
    this.wobble = Math.random() * Math.PI * 2;
    this.wobbleSpeed = 0.03 + Math.random() * 0.02;
    this.alive = true;
    this.deathTimer = 0;
    this.flashTimer = 0;
    this.hornSize = 8 + Math.random() * 6;

    // Visual style per type
    if (this.type === 'cert') {
      this.color = `hsl(${Math.random() * 20 + 355}, 80%, ${40 + Math.random() * 20}%)`;
      this.wingColor = 'rgba(80,0,0,0.7)';
      this.eyeColor = '#ff0';
      this.pupilColor = '#f00';
    } else if (this.type === 'demon') {
      this.color = `hsl(${270 + Math.random() * 30}, 70%, ${25 + Math.random() * 15}%)`;
      this.wingColor = 'rgba(60,0,80,0.8)';
      this.eyeColor = '#bf00ff';
      this.pupilColor = '#6a00a0';
      this.hornSize = 12 + Math.random() * 8;
    } else if (this.type === 'dabel') {
      this.color = `hsl(${Math.random() * 15}, 90%, ${15 + Math.random() * 10}%)`;
      this.wingColor = 'rgba(40,0,0,0.9)';
      this.eyeColor = '#ff4400';
      this.pupilColor = '#ff0000';
      this.hornSize = 16 + Math.random() * 10;
    }
  }

  update() {
    if (!this.alive) {
      this.deathTimer++;
      this.y += 3;
      return this.deathTimer < 30;
    }

    this.wobble += this.wobbleSpeed;
    this.wingAngle = Math.sin(this.wobble * 3) * 0.5;

    const dx = this.targetX - this.x + Math.sin(this.wobble) * 40;
    const dy = this.targetY - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > 5) {
      const spdMult = (prayerStates[0] && prayerStates[0].active) ? 0.6 : 1.0;
      this.x += (dx / dist) * this.speed * spdMult;
      this.y += (dy / dist) * this.speed * spdMult;
    } else {
      // Reached the church - damage!
      lives--;
      shakeTimer = 15;
      shakeIntensity = 8;
      updateLives();
      return false;
    }

    if (this.flashTimer > 0) this.flashTimer--;
    return true;
  }

  draw() {
    const s = this.size;
    const alpha = this.alive ? 1 : (1 - this.deathTimer / 30);

    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.globalAlpha = alpha;

    if (this.flashTimer > 0) {
      ctx.shadowColor = '#fff';
      ctx.shadowBlur = 20;
    }

    // Dabel: fiery aura glow
    if (this.type === 'dabel' && this.alive) {
      const glowR = s * 0.9 + Math.sin(this.wobble * 2) * 4;
      const auraGrad = ctx.createRadialGradient(0, 0, s * 0.2, 0, 0, glowR);
      auraGrad.addColorStop(0, 'rgba(255,60,0,0.25)');
      auraGrad.addColorStop(0.6, 'rgba(255,30,0,0.1)');
      auraGrad.addColorStop(1, 'rgba(255,0,0,0)');
      ctx.fillStyle = auraGrad;
      ctx.beginPath();
      ctx.arc(0, 0, glowR, 0, Math.PI * 2);
      ctx.fill();
    }

    // Demon: purple shadow aura
    if (this.type === 'demon' && this.alive) {
      const glowR = s * 0.7 + Math.sin(this.wobble * 1.5) * 3;
      const auraGrad = ctx.createRadialGradient(0, 0, s * 0.15, 0, 0, glowR);
      auraGrad.addColorStop(0, 'rgba(140,0,255,0.15)');
      auraGrad.addColorStop(1, 'rgba(80,0,160,0)');
      ctx.fillStyle = auraGrad;
      ctx.beginPath();
      ctx.arc(0, 0, glowR, 0, Math.PI * 2);
      ctx.fill();
    }

    // Wings
    const wingAlpha = this.alive ? 1 : 0.3;
    ctx.fillStyle = this.alive ? this.wingColor : this.wingColor.replace(/[\d.]+\)$/, (wingAlpha * 0.5) + ')');
    const wingScale = this.type === 'demon' ? 1.3 : this.type === 'dabel' ? 1.5 : 1.0;
    // Left wing
    ctx.save();
    ctx.rotate(-0.3 + this.wingAngle);
    ctx.beginPath();
    ctx.moveTo(-5, -5);
    ctx.quadraticCurveTo(-s * 1.2 * wingScale, -s * 0.8 * wingScale, -s * 0.8 * wingScale, 5);
    ctx.quadraticCurveTo(-s * 0.5, -5, -5, 0);
    ctx.fill();
    ctx.restore();
    // Right wing
    ctx.save();
    ctx.rotate(0.3 - this.wingAngle);
    ctx.beginPath();
    ctx.moveTo(5, -5);
    ctx.quadraticCurveTo(s * 1.2 * wingScale, -s * 0.8 * wingScale, s * 0.8 * wingScale, 5);
    ctx.quadraticCurveTo(s * 0.5, -5, 5, 0);
    ctx.fill();
    ctx.restore();

    // Body
    ctx.fillStyle = this.flashTimer > 0 ? '#fff' : this.color;
    ctx.beginPath();
    ctx.ellipse(0, 0, s * 0.4, s * 0.55, 0, 0, Math.PI * 2);
    ctx.fill();

    // Dabel: armor lines on body
    if (this.type === 'dabel') {
      ctx.strokeStyle = 'rgba(255,100,0,0.4)';
      ctx.lineWidth = 1.5;
      for (let i = -2; i <= 2; i++) {
        ctx.beginPath();
        ctx.moveTo(-s * 0.3, i * s * 0.12);
        ctx.lineTo(s * 0.3, i * s * 0.12);
        ctx.stroke();
      }
    }

    // Head
    ctx.fillStyle = this.flashTimer > 0 ? '#fff' : this.color;
    ctx.beginPath();
    ctx.arc(0, -s * 0.5, s * 0.3, 0, Math.PI * 2);
    ctx.fill();

    // Horns
    const hornColor = this.type === 'dabel' ? '#330000' : this.type === 'demon' ? '#1a001a' : '#1a0000';
    const hornWidth = this.type === 'dabel' ? 4 : this.type === 'demon' ? 3.5 : 3;
    ctx.strokeStyle = hornColor;
    ctx.lineWidth = hornWidth;
    ctx.beginPath();
    ctx.moveTo(-s * 0.15, -s * 0.7);
    ctx.quadraticCurveTo(-s * 0.4, -s * 1.1, -s * 0.1, -s * 0.95);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(s * 0.15, -s * 0.7);
    ctx.quadraticCurveTo(s * 0.4, -s * 1.1, s * 0.1, -s * 0.95);
    ctx.stroke();

    // Dabel: crown between horns
    if (this.type === 'dabel') {
      ctx.fillStyle = '#ff6600';
      ctx.beginPath();
      ctx.moveTo(-s * 0.15, -s * 0.85);
      ctx.lineTo(-s * 0.1, -s * 1.05);
      ctx.lineTo(0, -s * 0.9);
      ctx.lineTo(s * 0.1, -s * 1.05);
      ctx.lineTo(s * 0.15, -s * 0.85);
      ctx.closePath();
      ctx.fill();
    }

    // Eyes
    const eyeSize = this.type === 'dabel' ? 5 : this.type === 'demon' ? 4.5 : 4;
    const pupilSize = this.type === 'dabel' ? 2.5 : 2;
    ctx.fillStyle = this.eyeColor;
    ctx.beginPath();
    ctx.arc(-s * 0.1, -s * 0.5, eyeSize, 0, Math.PI * 2);
    ctx.arc(s * 0.1, -s * 0.5, eyeSize, 0, Math.PI * 2);
    ctx.fill();
    // Eye glow for demon and dabel
    if (this.type !== 'cert' && this.alive) {
      ctx.shadowColor = this.eyeColor;
      ctx.shadowBlur = 8;
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    // Pupils
    ctx.fillStyle = this.pupilColor;
    ctx.beginPath();
    ctx.arc(-s * 0.1, -s * 0.5, pupilSize, 0, Math.PI * 2);
    ctx.arc(s * 0.1, -s * 0.5, pupilSize, 0, Math.PI * 2);
    ctx.fill();

    // Mouth
    const mouthColor = this.type === 'dabel' ? '#ff4400' : this.type === 'demon' ? '#aa00ff' : '#ff3300';
    ctx.strokeStyle = mouthColor;
    ctx.lineWidth = this.type === 'dabel' ? 3 : 2;
    ctx.beginPath();
    ctx.arc(0, -s * 0.38, this.type === 'dabel' ? 8 : 6, 0, Math.PI);
    ctx.stroke();

    // Tail
    const tailWidth = this.type === 'dabel' ? 3.5 : this.type === 'demon' ? 2.5 : 2;
    ctx.strokeStyle = this.color;
    ctx.lineWidth = tailWidth;
    ctx.beginPath();
    ctx.moveTo(0, s * 0.5);
    ctx.quadraticCurveTo(s * 0.4, s * 0.8, s * 0.2, s * 0.9);
    ctx.stroke();
    // Tail tip (arrow)
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(s * 0.2, s * 0.85);
    ctx.lineTo(s * 0.35, s * 0.95);
    ctx.lineTo(s * 0.15, s * 1.0);
    ctx.closePath();
    ctx.fill();

    // HP text (always show for alive enemies)
    if (this.alive) {
      const hpRatio = Math.max(0, this.hp / this.maxHp);
      const hpTextColor = hpRatio > 0.75 ? '#44ff44' : hpRatio > 0.5 ? '#aaff00' : hpRatio > 0.25 ? '#ffcc00' : '#ff3333';
      ctx.font = 'bold 24px Segoe UI, Arial';
      ctx.textAlign = 'center';
      ctx.fillStyle = hpTextColor;
      ctx.fillText(Math.ceil(this.hp) + '/' + this.maxHp, 0, -s * 0.95 - 10);
      ctx.textAlign = 'start';
    }

    // Name label above HP text
    if (this.alive && (this.type === 'demon' || this.type === 'dabel')) {
      ctx.font = 'bold 10px Segoe UI, Arial';
      ctx.textAlign = 'center';
      ctx.fillStyle = this.type === 'dabel' ? '#ff4400' : '#bf00ff';
      ctx.fillText(this.type === 'dabel' ? 'DABEL' : 'DEMON', 0, -s * 0.95 - 28);
      ctx.textAlign = 'start';
    }

    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.restore();
  }

  hit(damage = 1) {
    this.hp -= damage;
    this.flashTimer = 5;
    if (this.hp <= 0) {
      this.alive = false;
      score += this.maxHp * this.scoreMult;
      devilsKilledInWave++;
      // Spawn death particles
      for (let i = 0; i < 12; i++) {
        particles.push({
          x: this.x, y: this.y,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6,
          life: 30 + Math.random() * 20,
          maxLife: 50,
          color: this.type === 'demon' ? `hsl(${270 + Math.random() * 30}, 90%, 50%)` : this.type === 'dabel' ? `hsl(${Math.random() * 20}, 100%, 40%)` : `hsl(${Math.random() * 30}, 90%, 50%)`,
          size: 3 + Math.random() * 4
        });
      }
      return true;
    }
    return false;
  }
}

// Holy water projectile
class HolyWater {
  constructor(x, y, tx, ty) {
    this.x = W / 2;
    this.y = H - 200;
    const dx = tx - this.x;
    const dy = ty - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const speed = 10;
    this.vx = (dx / dist) * speed;
    this.vy = (dy / dist) * speed;
    this.life = 100;
    this.size = 8;
    this.trail = [];
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.05; // slight gravity
    this.life--;

    this.trail.push({ x: this.x, y: this.y, life: 15 });
    if (this.trail.length > 10) this.trail.shift();
    this.trail.forEach(t => t.life--);

    return this.life > 0 && this.x > -20 && this.x < W + 20 && this.y > -20 && this.y < H + 20;
  }

  draw() {
    // Trail
    this.trail.forEach(t => {
      const alpha = t.life / 15;
      ctx.beginPath();
      ctx.arc(t.x, t.y, 3 * alpha, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(100,180,255,${alpha * 0.5})`;
      ctx.fill();
    });

    // Holy water drop
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fillStyle = '#7ec8f0';
    ctx.shadowColor = '#aae0ff';
    ctx.shadowBlur = 15;
    ctx.fill();
    ctx.shadowBlur = 0;

    // Cross symbol on the drop
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.x, this.y - 4);
    ctx.lineTo(this.x, this.y + 4);
    ctx.moveTo(this.x - 3, this.y - 1);
    ctx.lineTo(this.x + 3, this.y - 1);
    ctx.stroke();
  }

  checkCollision(devil) {
    const dx = this.x - devil.x;
    const dy = this.y - devil.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    return dist < devil.size * 0.6 + this.size;
  }
}

// Splash effect
class Splash {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.timer = 0;
    this.maxTimer = 25;
    this.drops = [];
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      this.drops.push({
        x: 0, y: 0,
        vx: Math.cos(angle) * (3 + Math.random() * 3),
        vy: Math.sin(angle) * (3 + Math.random() * 3),
        size: 2 + Math.random() * 3
      });
    }
  }

  update() {
    this.timer++;
    this.drops.forEach(d => {
      d.x += d.vx;
      d.y += d.vy;
      d.vy += 0.15;
    });
    return this.timer < this.maxTimer;
  }

  draw() {
    const alpha = 1 - this.timer / this.maxTimer;
    ctx.globalAlpha = alpha;

    // Central flash
    if (this.timer < 8) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, 20 - this.timer * 2, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(200,230,255,${alpha * 0.5})`;
      ctx.fill();

      // Cross flash
      ctx.strokeStyle = `rgba(255,255,200,${alpha})`;
      ctx.lineWidth = 3;
      const cs = 15 - this.timer;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y - cs);
      ctx.lineTo(this.x, this.y + cs);
      ctx.moveTo(this.x - cs, this.y);
      ctx.lineTo(this.x + cs, this.y);
      ctx.stroke();
    }

    // Drops
    this.drops.forEach(d => {
      ctx.beginPath();
      ctx.arc(this.x + d.x, this.y + d.y, d.size * alpha, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(150,210,255,${alpha})`;
      ctx.fill();
    });

    ctx.globalAlpha = 1;
  }
}

// Pistol bullet projectile
class PistolBullet {
  constructor(tx, ty) {
    this.x = W / 2;
    this.y = H - 200;
    const dx = tx - this.x;
    const dy = ty - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const wp = weapons[1];
    this.vx = (dx / dist) * wp.speed;
    this.vy = (dy / dist) * wp.speed;
    this.life = 80;
    this.size = wp.size;
    this.damage = wp.damage;
    this.trail = [];
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.01;
    this.life--;

    this.trail.push({ x: this.x, y: this.y, life: 8 });
    if (this.trail.length > 6) this.trail.shift();
    this.trail.forEach(t => t.life--);

    return this.life > 0 && this.x > -20 && this.x < W + 20 && this.y > -20 && this.y < H + 20;
  }

  draw() {
    // Trail - thin and fast
    this.trail.forEach(t => {
      const alpha = t.life / 8;
      ctx.beginPath();
      ctx.arc(t.x, t.y, 2 * alpha, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(170,220,255,${alpha * 0.4})`;
      ctx.fill();
    });

    // Bullet glow
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size + 2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(180,220,255,0.3)';
    ctx.fill();

    // Bullet core
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fillStyle = '#b0e0ff';
    ctx.shadowColor = '#ddf0ff';
    ctx.shadowBlur = 8;
    ctx.fill();
    ctx.shadowBlur = 0;

    // Tiny sparkle
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(this.x - 1, this.y - 1, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }

  checkCollision(devil) {
    const dx = this.x - devil.x;
    const dy = this.y - devil.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    return dist < devil.size * 0.6 + this.size;
  }
}

// Spray drop projectile
class SprayDrop {
  constructor(tx, ty, angleOffset) {
    this.x = W / 2;
    this.y = H - 200;
    const dx = tx - this.x;
    const dy = ty - this.y;
    const baseAngle = Math.atan2(dy, dx) + angleOffset;
    const wp = weapons[3];
    const speedVariance = wp.speed * (0.8 + Math.random() * 0.4);
    this.vx = Math.cos(baseAngle) * speedVariance;
    this.vy = Math.sin(baseAngle) * speedVariance;
    this.life = 50 + Math.random() * 20;
    this.size = wp.size * (0.7 + Math.random() * 0.6);
    this.damage = wp.damage;
    this.alpha = 0.7 + Math.random() * 0.3;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.08;
    this.life--;
    this.alpha *= 0.995;
    return this.life > 0 && this.x > -20 && this.x < W + 20 && this.y > -20 && this.y < H + 20;
  }

  draw() {
    ctx.globalAlpha = this.alpha * (this.life > 15 ? 1 : this.life / 15);
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fillStyle = '#a0d8ef';
    ctx.shadowColor = '#c0e8ff';
    ctx.shadowBlur = 4;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  }

  checkCollision(devil) {
    const dx = this.x - devil.x;
    const dy = this.y - devil.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    return dist < devil.size * 0.55 + this.size;
  }
}

// Kropenka bullet (machine gun water drop)
class KropenkaBullet {
  constructor(tx, ty) {
    this.x = W / 2;
    this.y = H - 200;
    const wp = weapons[2];
    const dx = tx - this.x;
    const dy = ty - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    // Small random spread
    const spread = (Math.random() - 0.5) * 0.06;
    const angle = Math.atan2(dy, dx) + spread;
    this.vx = Math.cos(angle) * wp.speed;
    this.vy = Math.sin(angle) * wp.speed;
    this.life = 70;
    this.size = wp.size;
    this.damage = wp.damage;
    this.trail = [];
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.02;
    this.life--;
    this.trail.push({ x: this.x, y: this.y, life: 6 });
    if (this.trail.length > 4) this.trail.shift();
    this.trail.forEach(t => t.life--);
    return this.life > 0 && this.x > -20 && this.x < W + 20 && this.y > -20 && this.y < H + 20;
  }

  draw() {
    // Short trail
    this.trail.forEach(t => {
      const alpha = t.life / 6;
      ctx.beginPath();
      ctx.arc(t.x, t.y, 1.5 * alpha, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(140,210,240,${alpha * 0.4})`;
      ctx.fill();
    });
    // Bullet
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fillStyle = '#90d0f0';
    ctx.shadowColor = '#b0e0ff';
    ctx.shadowBlur = 5;
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  checkCollision(devil) {
    const dx = this.x - devil.x;
    const dy = this.y - devil.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    return dist < devil.size * 0.6 + this.size;
  }
}

// Balloon class - water balloon that explodes on contact
class Balloon {
  constructor(tx, ty) {
    this.x = W / 2;
    this.y = H - 200;
    const wp = weapons[5];
    const dx = tx - this.x;
    const dy = ty - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    this.vx = Math.cos(angle) * wp.speed;
    this.vy = Math.sin(angle) * wp.speed;
    this.size = wp.size;
    this.damage = wp.damage;
    this.explosionRadius = wp.explosionRadius;
    this.life = 180;
    this.wobble = 0;
    this.color = wp.color;
    // Random slight color tint
    const hues = ['#4da6ff', '#5cb3ff', '#3d99f0', '#6bc0ff'];
    this.color = hues[Math.floor(Math.random() * hues.length)];
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.015; // Very slight gravity - balloons float
    this.wobble += 0.12;
    this.life--;
    return this.life > 0 && this.x > -30 && this.x < W + 30 && this.y > -30 && this.y < H + 30;
  }

  draw() {
    const wobbleX = Math.sin(this.wobble) * 2;
    const wobbleY = Math.cos(this.wobble * 0.7) * 1.5;
    const bx = this.x + wobbleX;
    const by = this.y + wobbleY;

    // Balloon shadow/glow
    ctx.beginPath();
    ctx.arc(bx, by, this.size + 3, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(77,166,255,0.15)';
    ctx.fill();

    // Balloon body (oval)
    ctx.save();
    ctx.translate(bx, by);
    ctx.scale(1, 1.15);
    ctx.beginPath();
    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
    ctx.fillStyle = this.color;
    ctx.fill();
    // Highlight
    ctx.beginPath();
    ctx.arc(-3, -4, this.size * 0.4, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.fill();
    ctx.restore();

    // Knot at bottom
    ctx.beginPath();
    ctx.moveTo(bx - 3, by + this.size * 1.15);
    ctx.lineTo(bx, by + this.size * 1.15 + 5);
    ctx.lineTo(bx + 3, by + this.size * 1.15);
    ctx.fillStyle = this.color;
    ctx.fill();

    // String
    ctx.strokeStyle = 'rgba(200,220,255,0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(bx, by + this.size * 1.15 + 5);
    ctx.quadraticCurveTo(bx + Math.sin(this.wobble * 1.5) * 4, by + this.size * 1.15 + 12, bx + Math.sin(this.wobble) * 2, by + this.size * 1.15 + 18);
    ctx.stroke();

    // Water shimmer inside
    ctx.fillStyle = 'rgba(150,210,255,0.2)';
    const waterLevel = Math.sin(this.wobble * 0.5) * 2;
    ctx.beginPath();
    ctx.arc(bx, by + 2 + waterLevel, this.size * 0.6, 0, Math.PI);
    ctx.fill();
  }

  checkCollision(devil) {
    const dx = this.x - devil.x;
    const dy = this.y - devil.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    return dist < devil.size * 0.6 + this.size;
  }
}

// Angel class
class Angel {
  constructor() {
    this.size = 28;
    this.speed = 0.6 + Math.random() * 0.3;

    // Spawn from left or right
    if (Math.random() < 0.5) {
      this.x = -this.size;
    } else {
      this.x = W + this.size;
    }
    this.y = H * 0.2 + Math.random() * H * 0.3;

    this.targetX = W / 2 + (Math.random() - 0.5) * 100;
    this.targetY = H - 300 + Math.random() * 40;
    this.alive = true;
    this.reachedChurch = false;
    this.deathTimer = 0;
    this.deathType = ''; // 'saved' or 'caught'
    this.wingAngle = 0;
    this.wobble = Math.random() * Math.PI * 2;
    this.glowPhase = Math.random() * Math.PI * 2;
    this.haloGlow = 0;
  }

  update() {
    if (!this.alive) {
      this.deathTimer++;
      if (this.deathType === 'saved') {
        this.y -= 2;
      } else {
        this.y += 1;
        this.x += (Math.random() - 0.5) * 2;
      }
      return this.deathTimer < 50;
    }

    this.wobble += 0.04;
    this.wingAngle = Math.sin(this.wobble * 2.5) * 0.6;
    this.glowPhase += 0.05;
    this.haloGlow = 0.5 + Math.sin(this.glowPhase) * 0.3;

    const dx = this.targetX - this.x + Math.sin(this.wobble) * 20;
    const dy = this.targetY - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > 10) {
      this.x += (dx / dist) * this.speed;
      this.y += (dy / dist) * this.speed;
    } else {
      // Reached church - grant life!
      this.alive = false;
      this.deathType = 'saved';
      this.reachedChurch = true;
      if (lives < 5) {
        lives++;
        updateLives();
      }
      // Heavenly particle burst
      for (let i = 0; i < 20; i++) {
        particles.push({
          x: this.x, y: this.y,
          vx: (Math.random() - 0.5) * 5,
          vy: -Math.random() * 4 - 1,
          life: 40 + Math.random() * 30,
          maxLife: 70,
          color: `hsl(${45 + Math.random() * 20}, 100%, ${70 + Math.random() * 20}%)`,
          size: 2 + Math.random() * 3
        });
      }
      return true;
    }
    return true;
  }

  draw() {
    const s = this.size;
    const alpha = this.alive ? 1 : Math.max(0, 1 - this.deathTimer / 50);

    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.globalAlpha = alpha;

    // Outer holy glow
    const glowR = s * 1.5 + Math.sin(this.glowPhase) * 5;
    const outerGlow = ctx.createRadialGradient(0, -s * 0.2, 0, 0, -s * 0.2, glowR);
    outerGlow.addColorStop(0, `rgba(255,255,200,${this.haloGlow * 0.2})`);
    outerGlow.addColorStop(0.5, `rgba(255,230,150,${this.haloGlow * 0.1})`);
    outerGlow.addColorStop(1, 'rgba(255,230,150,0)');
    ctx.fillStyle = outerGlow;
    ctx.beginPath();
    ctx.arc(0, -s * 0.2, glowR, 0, Math.PI * 2);
    ctx.fill();

    // Wings
    ctx.fillStyle = 'rgba(255,255,240,0.6)';
    // Left wing
    ctx.save();
    ctx.rotate(-0.2 + this.wingAngle);
    ctx.beginPath();
    ctx.moveTo(-3, -3);
    ctx.quadraticCurveTo(-s * 1.4, -s * 1.0, -s * 0.6, 5);
    ctx.quadraticCurveTo(-s * 0.3, -3, -3, 0);
    ctx.fill();
    // Wing feather lines
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 0.5;
    for (let f = 0; f < 4; f++) {
      const t = (f + 1) / 5;
      ctx.beginPath();
      ctx.moveTo(-3 - t * (s * 1.1), -3 + t * (-s * 0.7) + (1 - t) * 8);
      ctx.lineTo(-3 - t * (s * 0.8), 5 - t * 2);
      ctx.stroke();
    }
    ctx.restore();
    // Right wing
    ctx.save();
    ctx.rotate(0.2 - this.wingAngle);
    ctx.beginPath();
    ctx.moveTo(3, -3);
    ctx.quadraticCurveTo(s * 1.4, -s * 1.0, s * 0.6, 5);
    ctx.quadraticCurveTo(s * 0.3, -3, 3, 0);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 0.5;
    for (let f = 0; f < 4; f++) {
      const t = (f + 1) / 5;
      ctx.beginPath();
      ctx.moveTo(3 + t * (s * 1.1), -3 + t * (-s * 0.7) + (1 - t) * 8);
      ctx.lineTo(3 + t * (s * 0.8), 5 - t * 2);
      ctx.stroke();
    }
    ctx.restore();

    // Body (white robe)
    const robeGrd = ctx.createLinearGradient(0, -s * 0.2, 0, s * 0.6);
    robeGrd.addColorStop(0, '#fff');
    robeGrd.addColorStop(1, '#ddd');
    ctx.fillStyle = robeGrd;
    ctx.beginPath();
    ctx.ellipse(0, s * 0.1, s * 0.3, s * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head
    ctx.fillStyle = '#ffe8cc';
    ctx.beginPath();
    ctx.arc(0, -s * 0.4, s * 0.22, 0, Math.PI * 2);
    ctx.fill();

    // Eyes (gentle, closed)
    ctx.strokeStyle = '#886644';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(-s * 0.08, -s * 0.42, 3, 0.2, Math.PI - 0.2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(s * 0.08, -s * 0.42, 3, 0.2, Math.PI - 0.2);
    ctx.stroke();

    // Gentle smile
    ctx.strokeStyle = '#aa7755';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0, -s * 0.33, 4, 0.3, Math.PI - 0.3);
    ctx.stroke();

    // Halo
    ctx.strokeStyle = `rgba(255,215,0,${0.6 + this.haloGlow * 0.4})`;
    ctx.shadowColor = '#ffd700';
    ctx.shadowBlur = 8 + Math.sin(this.glowPhase) * 4;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(0, -s * 0.65, s * 0.2, s * 0.06, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Death effects
    if (!this.alive && this.deathType === 'caught') {
      // Fading red X
      ctx.strokeStyle = `rgba(255,80,80,${alpha})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-12, -12); ctx.lineTo(12, 12);
      ctx.moveTo(12, -12); ctx.lineTo(-12, 12);
      ctx.stroke();
    }

    ctx.globalAlpha = 1;
    ctx.restore();
  }
}

function updateLives() {
  let hearts = '';
  for (let i = 0; i < lives; i++) hearts += '\u2764 ';
  for (let i = lives; i < 5; i++) hearts += '\u2661 ';
  document.getElementById('livesDisplay').textContent = hearts;
}

function updateScore() {
  document.getElementById('scoreDisplay').textContent = 'Skore: ' + score;
}

function updateWave() {
  document.getElementById('waveDisplay').textContent = 'Vlna: ' + wave + '/' + totalWaves;
}

// Weapon HUD drawing
function drawWeaponHUD() {
  const hudX = 20;
  const hudY = H - 90;
  const slotW = 60;
  const slotH = 50;
  const gap = 8;

  for (let i = 0; i < weapons.length; i++) {
    const sx = hudX + i * (slotW + gap);
    const sy = hudY;
    const isActive = i === currentWeapon;

    // Slot background
    ctx.fillStyle = isActive ? 'rgba(255,215,0,0.25)' : 'rgba(0,0,0,0.5)';
    ctx.strokeStyle = isActive ? '#ffd700' : '#555';
    ctx.lineWidth = isActive ? 2.5 : 1.5;
    ctx.beginPath();
    ctx.roundRect(sx, sy, slotW, slotH, 6);
    ctx.fill();
    ctx.stroke();

    // Active glow
    if (isActive && weaponSwitchTimer > 0) {
      ctx.strokeStyle = `rgba(255,215,0,${weaponSwitchTimer / 30 * 0.6})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.roundRect(sx - 2, sy - 2, slotW + 4, slotH + 4, 8);
      ctx.stroke();
    }

    // Weapon icon
    ctx.save();
    ctx.translate(sx + slotW / 2, sy + slotH / 2 - 4);
    if (i === 0) {
      // Holy water drop icon
      ctx.fillStyle = isActive ? '#7ec8f0' : '#5a8aa0';
      ctx.beginPath();
      ctx.moveTo(0, -12);
      ctx.quadraticCurveTo(12, 6, 0, 14);
      ctx.quadraticCurveTo(-12, 6, 0, -12);
      ctx.fill();
      // Cross on drop
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(0, -2); ctx.lineTo(0, 8);
      ctx.moveTo(-4, 2); ctx.lineTo(4, 2);
      ctx.stroke();
    } else if (i === 1) {
      // Pistol icon
      ctx.fillStyle = isActive ? '#b0e0ff' : '#6a8a9a';
      // Barrel
      ctx.fillRect(-12, -4, 18, 6);
      // Grip
      ctx.fillRect(-2, 2, 8, 12);
      // Trigger guard
      ctx.strokeStyle = isActive ? '#b0e0ff' : '#6a8a9a';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(2, 6, 4, 0, Math.PI);
      ctx.stroke();
      // Muzzle flash hint
      if (isActive) {
        ctx.fillStyle = 'rgba(180,230,255,0.4)';
        ctx.beginPath();
        ctx.arc(8, -1, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if (i === 2) {
      // Kropenka icon - machine gun with water drops
      const col = isActive ? '#90d0f0' : '#5a8a9a';
      // Gun barrel (longer, thinner)
      ctx.fillStyle = col;
      ctx.fillRect(-14, -3, 22, 5);
      // Muzzle
      ctx.fillRect(8, -5, 4, 9);
      // Grip
      ctx.fillRect(-6, 2, 6, 10);
      // Magazine
      ctx.fillStyle = isActive ? '#70b8d8' : '#4a7a8a';
      ctx.fillRect(-10, 2, 5, 8);
      // Water drops from muzzle
      if (isActive) {
        ctx.fillStyle = 'rgba(144,208,240,0.6)';
        for (let d = 0; d < 3; d++) {
          const dx = 14 + d * 4 + Math.random() * 2;
          const dy = -2 + (Math.random() - 0.5) * 6;
          ctx.beginPath();
          ctx.arc(dx, dy, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    } else if (i === 3) {
      // Spray icon - bottle with spray lines
      const col = isActive ? '#a0d8ef' : '#6a8a9a';
      ctx.fillStyle = col;
      // Bottle body
      ctx.fillRect(-5, -2, 10, 14);
      // Bottle neck
      ctx.fillRect(-3, -6, 6, 5);
      // Nozzle
      ctx.fillRect(-6, -8, 12, 3);
      // Spray lines
      ctx.strokeStyle = isActive ? 'rgba(160,216,239,0.7)' : 'rgba(106,138,154,0.5)';
      ctx.lineWidth = 1;
      for (let s = -2; s <= 2; s++) {
        const ang = s * 0.2;
        ctx.beginPath();
        ctx.moveTo(0, -9);
        ctx.lineTo(Math.sin(ang) * 12, -9 - Math.cos(ang) * 10);
        ctx.stroke();
      }
      // Spray dots
      if (isActive) {
        ctx.fillStyle = 'rgba(160,216,239,0.5)';
        for (let s = 0; s < 5; s++) {
          const da = (Math.random() - 0.5) * 0.5;
          const dd = 8 + Math.random() * 6;
          ctx.beginPath();
          ctx.arc(Math.sin(da) * dd, -9 - Math.cos(da) * dd, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    } else if (i === 4) {
      // Beam icon - vertical beam with waves
      const col = isActive ? '#50c8ff' : '#3a7a9a';
      // Beam line (thick vertical)
      ctx.strokeStyle = col;
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(0, 12); ctx.lineTo(0, -10);
      ctx.stroke();
      // Glow
      if (isActive) {
        ctx.strokeStyle = 'rgba(80,200,255,0.3)';
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.moveTo(0, 12); ctx.lineTo(0, -10);
        ctx.stroke();
      }
      // Side waves
      ctx.strokeStyle = isActive ? 'rgba(80,200,255,0.6)' : 'rgba(58,122,154,0.4)';
      ctx.lineWidth = 1;
      for (let s = -1; s <= 1; s += 2) {
        ctx.beginPath();
        ctx.moveTo(s * 4, 8);
        ctx.quadraticCurveTo(s * 8, 0, s * 4, -8);
        ctx.stroke();
      }
      // Cross at top
      ctx.strokeStyle = col;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(-4, -10); ctx.lineTo(4, -10);
      ctx.stroke();
    } else if (i === 5) {
      // Balloon icon
      const col = isActive ? '#4da6ff' : '#3a7090';
      // Balloon body (oval)
      ctx.save();
      ctx.scale(1, 1.2);
      ctx.beginPath();
      ctx.arc(0, -2, 9, 0, Math.PI * 2);
      ctx.fillStyle = col;
      ctx.fill();
      // Highlight
      ctx.beginPath();
      ctx.arc(-2, -5, 3, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.fill();
      ctx.restore();
      // Knot
      ctx.beginPath();
      ctx.moveTo(-2, 10); ctx.lineTo(0, 13); ctx.lineTo(2, 10);
      ctx.fillStyle = col;
      ctx.fill();
      // String
      ctx.strokeStyle = isActive ? 'rgba(200,220,255,0.6)' : 'rgba(100,130,150,0.4)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, 13);
      ctx.quadraticCurveTo(3, 17, -1, 20);
      ctx.stroke();
      // Explosion hint
      if (isActive) {
        ctx.strokeStyle = 'rgba(77,166,255,0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 2]);
        ctx.beginPath();
        ctx.arc(0, 0, 14, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }
    ctx.restore();

    // Key number
    ctx.fillStyle = isActive ? '#ffd700' : '#888';
    ctx.font = 'bold 11px Segoe UI, Arial';
    ctx.textAlign = 'center';
    ctx.fillText(weapons[i].key, sx + slotW / 2, sy + slotH - 3);

    // Info above slot
    ctx.font = '16px Segoe UI, Arial';
    if (i === 0 || i === 3 || i === 4 || i === 5) {
      // Water cost
      ctx.fillStyle = isActive ? '#aadcf0' : '#667';
      const costLabel = i === 4 ? weapons[i].waterCost + '%/s' : weapons[i].waterCost + '%';
      ctx.fillText(costLabel, sx + slotW / 2, sy - 12);
    } else if (i === 1) {
      // Ammo count for pistol
      if (pistolReloading) {
        ctx.fillStyle = '#ffaa00';
        ctx.fillText('_: ' + pistolReloadWaterCost + '%', sx + slotW / 2, sy - 12);
      } else if (pistolAmmo === 0) {
        ctx.fillStyle = '#ff4444';
        ctx.fillText('[_] dobit', sx + slotW / 2, sy - 12);
      } else {
        ctx.fillStyle = isActive ? '#aadcf0' : '#667';
        ctx.fillText(pistolAmmo + '/' + pistolMagMax, sx + slotW / 2, sy - 12);
      }
    } else if (i === 2) {
      // Ammo count for kropenka
      if (kropenkaReloading) {
        ctx.fillStyle = '#ffaa00';
        ctx.fillText('_: ' + kropenkaReloadWaterCost + '%', sx + slotW / 2, sy - 12);
      } else if (kropenkaAmmo === 0) {
        ctx.fillStyle = '#ff4444';
        ctx.fillText('[_] dobit', sx + slotW / 2, sy - 12);
      } else {
        ctx.fillStyle = isActive ? '#aadcf0' : '#667';
        ctx.fillText(kropenkaAmmo + '/' + kropenkaMagMax, sx + slotW / 2, sy - 12);
      }
    }
    ctx.textAlign = 'start';

    // Pistol reload progress bar overlay
    if (i === 1 && pistolReloading) {
      const reloadProgress = pistolReloadTimer / pistolReloadTime;
      // Dark overlay
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.beginPath();
      ctx.roundRect(sx, sy, slotW, slotH, 6);
      ctx.fill();
      // Progress bar
      ctx.fillStyle = '#ffaa00';
      ctx.fillRect(sx + 4, sy + slotH - 8, (slotW - 8) * reloadProgress, 4);
      ctx.fillStyle = '#553300';
      ctx.fillRect(sx + 4, sy + slotH - 8, slotW - 8, 4);
      ctx.fillStyle = '#ffaa00';
      ctx.fillRect(sx + 4, sy + slotH - 8, (slotW - 8) * reloadProgress, 4);
    }

    // Pistol empty ammo indicator - red border flash
    if (i === 1 && pistolAmmo === 0 && !pistolReloading && isActive) {
      const flashAlpha = 0.3 + Math.sin(waterFlashTimer * 3) * 0.3;
      ctx.strokeStyle = `rgba(255,50,50,${flashAlpha})`;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.roundRect(sx, sy, slotW, slotH, 6);
      ctx.stroke();
    }

    // Kropenka reload progress bar overlay
    if (i === 2 && kropenkaReloading) {
      const reloadProgress = kropenkaReloadTimer / kropenkaReloadTime;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.beginPath();
      ctx.roundRect(sx, sy, slotW, slotH, 6);
      ctx.fill();
      ctx.fillStyle = '#553300';
      ctx.fillRect(sx + 4, sy + slotH - 8, slotW - 8, 4);
      ctx.fillStyle = '#ffaa00';
      ctx.fillRect(sx + 4, sy + slotH - 8, (slotW - 8) * reloadProgress, 4);
    }

    // Kropenka empty ammo indicator - red border flash
    if (i === 2 && kropenkaAmmo === 0 && !kropenkaReloading && isActive) {
      const flashAlpha = 0.3 + Math.sin(waterFlashTimer * 3) * 0.3;
      ctx.strokeStyle = `rgba(255,50,50,${flashAlpha})`;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.roundRect(sx, sy, slotW, slotH, 6);
      ctx.stroke();
    }
  }

  if (weaponSwitchTimer > 0) weaponSwitchTimer--;
}

// Prayer HUD drawing
function drawPrayerHUD() {
  const px = W - 90, py = H - 90, pw = 70, ph = 60;

  for (let i = 0; i < prayers.length; i++) {
    const p = prayers[i];
    const ps = prayerStates[i];
    const sx = px - i * (pw + 10);
    const sy = py;
    const isReady = !ps.active && ps.cooldownTimer <= 0 && water >= p.waterCost;
    const isActive = ps.active;
    const isCooldown = !ps.active && ps.cooldownTimer > 0;

    // Slot background
    ctx.fillStyle = isActive ? 'rgba(100,200,255,0.3)' : isCooldown ? 'rgba(0,0,0,0.7)' : 'rgba(0,0,0,0.5)';
    ctx.strokeStyle = isActive ? '#50c8ff' : isReady ? '#aadcf0' : '#444';
    ctx.lineWidth = isActive ? 3 : 1.5;
    ctx.beginPath();
    ctx.roundRect(sx, sy, pw, ph, 8);
    ctx.fill();
    ctx.stroke();

    // Active glow pulse
    if (isActive) {
      const pulse = 0.3 + Math.sin(Date.now() * 0.006) * 0.2;
      ctx.shadowColor = '#50c8ff';
      ctx.shadowBlur = 15;
      ctx.strokeStyle = `rgba(80,200,255,${pulse})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.roundRect(sx, sy, pw, ph, 8);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    // Prayer icon
    ctx.save();
    ctx.translate(sx + pw / 2, sy + ph / 2 - 6);
    const iconColor = isActive ? '#50c8ff' : isCooldown ? '#555' : isReady ? '#aadcf0' : '#667';
    ctx.strokeStyle = iconColor;
    ctx.fillStyle = iconColor;
    ctx.lineWidth = 2;

    if (i === 0) {
      // Snowflake icon (Zpomalen)
      for (let a = 0; a < 3; a++) {
        const ang = a * Math.PI / 3;
        ctx.beginPath();
        ctx.moveTo(Math.cos(ang) * 10, Math.sin(ang) * 10);
        ctx.lineTo(-Math.cos(ang) * 10, -Math.sin(ang) * 10);
        ctx.stroke();
        for (let dir = -1; dir <= 1; dir += 2) {
          const bx = Math.cos(ang) * 6 * dir;
          const by = Math.sin(ang) * 6 * dir;
          const branchAng = ang + Math.PI / 4;
          ctx.beginPath();
          ctx.moveTo(bx, by);
          ctx.lineTo(bx + Math.cos(branchAng) * 3 * dir, by + Math.sin(branchAng) * 3 * dir);
          ctx.stroke();
        }
      }
      ctx.beginPath();
      ctx.arc(0, 0, 2, 0, Math.PI * 2);
      ctx.fill();
    } else if (i === 1) {
      // Lightning bolt icon (Blesky)
      const boltColor = isActive ? '#ffee44' : iconColor;
      ctx.strokeStyle = boltColor;
      ctx.fillStyle = boltColor;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(2, -12);
      ctx.lineTo(-4, -2);
      ctx.lineTo(1, -2);
      ctx.lineTo(-3, 12);
      ctx.lineTo(5, 1);
      ctx.lineTo(0, 1);
      ctx.lineTo(2, -12);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
    ctx.restore();

    // Progress bar (active countdown or cooldown)
    if (isActive) {
      const progress = ps.timer / p.duration;
      ctx.fillStyle = 'rgba(80,200,255,0.4)';
      ctx.fillRect(sx + 3, sy + ph - 7, (pw - 6) * progress, 4);
      ctx.strokeStyle = '#50c8ff';
      ctx.lineWidth = 0.5;
      ctx.strokeRect(sx + 3, sy + ph - 7, pw - 6, 4);
    } else if (isCooldown) {
      const progress = ps.cooldownTimer / p.cooldown;
      ctx.fillStyle = 'rgba(80,80,80,0.6)';
      ctx.fillRect(sx + 3, sy + ph - 7, (pw - 6) * progress, 4);
      // Cooldown overlay on whole slot
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.beginPath();
      ctx.roundRect(sx, sy, pw, ph * progress, 8);
      ctx.fill();
    }

    // Key label
    ctx.font = 'bold 10px Segoe UI, Arial';
    ctx.textAlign = 'center';
    ctx.fillStyle = isActive ? '#50c8ff' : '#888';
    ctx.fillText(p.key, sx + pw / 2, sy + ph - 2);

    // Water cost above slot
    ctx.font = '14px Segoe UI, Arial';
    ctx.fillStyle = isActive ? '#50c8ff' : isReady ? '#aadcf0' : '#667';
    ctx.fillText(p.waterCost + '%', sx + pw / 2, sy - 5);

    // Status text
    if (isActive) {
      ctx.font = 'bold 11px Segoe UI, Arial';
      ctx.fillStyle = '#50c8ff';
      ctx.fillText(Math.ceil(ps.timer / 60) + 's', sx + pw / 2, sy - 18);
    } else if (isCooldown) {
      ctx.font = 'bold 11px Segoe UI, Arial';
      ctx.fillStyle = '#666';
      ctx.fillText(Math.ceil(ps.cooldownTimer / 60) + 's', sx + pw / 2, sy - 18);
    }

    ctx.textAlign = 'start';
  }
}

// Wave banner drawing
function drawWaveBanner() {
  if (waveBannerTimer <= 0) return;

  const progress = waveBannerTimer / waveBannerDuration;
  // Slide in and fade out
  let alpha, yOff;
  if (progress > 0.8) {
    // Slide in (first 20%)
    const t = (1 - progress) / 0.2;
    alpha = t;
    yOff = (1 - t) * -30;
  } else if (progress < 0.2) {
    // Fade out (last 20%)
    alpha = progress / 0.2;
    yOff = 0;
  } else {
    alpha = 1;
    yOff = 0;
  }

  const cy = H * 0.28 + yOff;
  ctx.save();
  ctx.globalAlpha = alpha;

  // Dark backdrop
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, cy - 30, W, 60);

  // Colored line top/bottom
  const lineColor = wave >= 8 ? '#ff4444' : wave >= 5 ? '#ff8800' : '#ffd700';
  ctx.fillStyle = lineColor;
  ctx.fillRect(0, cy - 30, W, 2);
  ctx.fillRect(0, cy + 28, W, 2);

  // Wave text
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Wave number
  ctx.font = 'bold 28px Segoe UI, Arial';
  ctx.fillStyle = lineColor;
  ctx.shadowColor = lineColor;
  ctx.shadowBlur = 10;
  ctx.fillText(waveBanner, W / 2, cy);
  ctx.shadowBlur = 0;

  ctx.globalAlpha = 1;
  ctx.textAlign = 'start';
  ctx.restore();
}

// Water tank drawing
function drawWaterTank() {
  const barW = 400;
  const barH = 38;
  const barX = (W - barW) / 2;
  const barY = H - 48;
  const fill = water / waterMax;
  const isLow = water < weapons[currentWeapon].waterCost;

  // Tank background (stone look)
  ctx.fillStyle = '#2a2a2a';
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 2;
  // Rounded rect
  const r = 6;
  ctx.beginPath();
  ctx.moveTo(barX + r, barY);
  ctx.lineTo(barX + barW - r, barY);
  ctx.quadraticCurveTo(barX + barW, barY, barX + barW, barY + r);
  ctx.lineTo(barX + barW, barY + barH - r);
  ctx.quadraticCurveTo(barX + barW, barY + barH, barX + barW - r, barY + barH);
  ctx.lineTo(barX + r, barY + barH);
  ctx.quadraticCurveTo(barX, barY + barH, barX, barY + barH - r);
  ctx.lineTo(barX, barY + r);
  ctx.quadraticCurveTo(barX, barY, barX + r, barY);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Water fill with wave animation
  const fillW = (barW - 4) * fill;
  if (fillW > 0) {
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(barX + 2 + r, barY + 2);
    ctx.lineTo(barX + 2 + fillW - (fillW > r ? 0 : 0), barY + 2);
    ctx.lineTo(barX + 2 + fillW, barY + barH - 2);
    ctx.lineTo(barX + 2, barY + barH - 2);
    ctx.closePath();
    ctx.clip();

    // Water gradient
    const wGrd = ctx.createLinearGradient(barX, barY, barX, barY + barH);
    if (isLow && Math.sin(waterFlashTimer) > 0) {
      wGrd.addColorStop(0, 'rgba(255,80,80,0.9)');
      wGrd.addColorStop(1, 'rgba(180,40,40,0.9)');
    } else {
      wGrd.addColorStop(0, 'rgba(120,200,240,0.9)');
      wGrd.addColorStop(0.5, 'rgba(80,160,220,0.9)');
      wGrd.addColorStop(1, 'rgba(50,120,200,0.9)');
    }
    ctx.fillStyle = wGrd;
    ctx.fillRect(barX + 2, barY + 2, fillW, barH - 4);

    // Animated wave on top of water
    ctx.beginPath();
    ctx.moveTo(barX + 2, barY + 2);
    for (let wx = 0; wx <= fillW; wx += 2) {
      const waveY = Math.sin((wx * 0.05) + crossGlow * 3) * 2;
      ctx.lineTo(barX + 2 + wx, barY + 4 + waveY);
    }
    ctx.lineTo(barX + 2 + fillW, barY + 2);
    ctx.closePath();
    ctx.fillStyle = 'rgba(180,230,255,0.4)';
    ctx.fill();

    // Shine highlight
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(barX + 4, barY + 4, fillW - 4, 6);

    ctx.restore();
  }

  // Border overlay
  ctx.strokeStyle = '#777';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(barX + r, barY);
  ctx.lineTo(barX + barW - r, barY);
  ctx.quadraticCurveTo(barX + barW, barY, barX + barW, barY + r);
  ctx.lineTo(barX + barW, barY + barH - r);
  ctx.quadraticCurveTo(barX + barW, barY + barH, barX + barW - r, barY + barH);
  ctx.lineTo(barX + r, barY + barH);
  ctx.quadraticCurveTo(barX, barY + barH, barX, barY + barH - r);
  ctx.lineTo(barX, barY + r);
  ctx.quadraticCurveTo(barX, barY, barX + r, barY);
  ctx.closePath();
  ctx.stroke();

  // Cross icon on left
  ctx.strokeStyle = '#ffd700';
  ctx.lineWidth = 2;
  const ix = barX - 20;
  const iy = barY + barH / 2;
  ctx.beginPath();
  ctx.moveTo(ix, iy - 8); ctx.lineTo(ix, iy + 8);
  ctx.moveTo(ix - 5, iy - 2); ctx.lineTo(ix + 5, iy - 2);
  ctx.stroke();

  // Drop icon on right
  ctx.fillStyle = '#7ec8f0';
  ctx.beginPath();
  ctx.moveTo(barX + barW + 15, barY + 6);
  ctx.quadraticCurveTo(barX + barW + 22, barY + barH - 4, barX + barW + 15, barY + barH - 2);
  ctx.quadraticCurveTo(barX + barW + 8, barY + barH - 4, barX + barW + 15, barY + 6);
  ctx.fill();

  // Percentage text
  ctx.fillStyle = isLow ? '#ff6666' : '#fff';
  ctx.font = 'bold 18px Segoe UI, Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(Math.round(water) + '%', barX + barW / 2, barY + barH / 2 + 1);
  ctx.textAlign = 'start';

  waterFlashTimer += 0.15;
}

// ============ INPUT SYSTEM ============
// Pointer Lock for raw mouse (bypasses OS keyboard-mouse throttling)
let pointerLocked = false;

function lockPointer() {
  if (!pointerLocked) canvas.requestPointerLock();
}

document.addEventListener('pointerlockchange', () => {
  pointerLocked = document.pointerLockElement === canvas;
});

// Mouse movement accumulator - collects deltas between frames
let moveDeltaX = 0;
let moveDeltaY = 0;

document.addEventListener('mousemove', (e) => {
  if (pointerLocked) {
    moveDeltaX += e.movementX;
    moveDeltaY += e.movementY;
  } else {
    mouseX = e.clientX;
    mouseY = e.clientY;
  }
});

// Apply accumulated mouse deltas once per frame (called in game loop)
function applyMouseDeltas() {
  if (pointerLocked) {
    mouseX = Math.max(0, Math.min(W, mouseX + moveDeltaX));
    mouseY = Math.max(0, Math.min(H, mouseY + moveDeltaY));
  }
  moveDeltaX = 0;
  moveDeltaY = 0;
}

// Keyboard - just track state, nothing else
document.addEventListener('keydown', (e) => {
  if (e.key === ' ') e.preventDefault();
  if (e.repeat) return;
  const k = e.key.toLowerCase();
  keysJustPressed[k] = true;
  keysDown[k] = true;
});
document.addEventListener('keyup', (e) => {
  if (e.key === ' ') e.preventDefault();
  keysDown[e.key.toLowerCase()] = false;
});

// Shoot
function shoot() {
  if (!gameRunning) return;
  if (currentWeapon === 0) {
    if (water < weapons[0].waterCost) { waterFlashTimer = 0; return; }
    water -= weapons[0].waterCost;
    holyWaters.push(new HolyWater(W / 2, H - 200, mouseX, mouseY));
  } else if (currentWeapon === 1) {
    if (pistolReloading) return;
    if (pistolAmmo <= 0) { weaponSwitchTimer = 15; return; }
    pistolAmmo--;
    pistolBullets.push(new PistolBullet(mouseX, mouseY));
  } else if (currentWeapon === 3) {
    const wp = weapons[3];
    if (water < wp.waterCost) { waterFlashTimer = 0; return; }
    water -= wp.waterCost;
    const spreadRad = (wp.spreadAngle / 2) * (Math.PI / 180);
    for (let d = 0; d < wp.dropCount; d++) {
      sprayDrops.push(new SprayDrop(mouseX, mouseY, (Math.random() * 2 - 1) * spreadRad));
    }
  } else if (currentWeapon === 4) {
    // Svaty proud - single powerful beam shot
    const wp = weapons[4];
    if (water < wp.waterCost) { waterFlashTimer = 0; return; }
    water -= wp.waterCost;
    const bx1 = W / 2, by1 = H - 200;
    // Extend beam far past cursor
    const dx = mouseX - bx1, dy = mouseY - by1;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const extendDist = Math.max(W, H) * 2;
    const bx2 = bx1 + (dx / dist) * extendDist;
    const by2 = by1 + (dy / dist) * extendDist;
    // Start flash animation
    beamFlash = { x1: bx1, y1: by1, x2: bx2, y2: by2, timer: 0, maxTimer: 25 };
    // Hit all devils in beam path
    const bdx = bx2 - bx1, bdy = by2 - by1;
    const bLen = Math.sqrt(bdx * bdx + bdy * bdy);
    const halfW = wp.beamWidth / 2;
    shakeTimer = 10;
    shakeIntensity = 6;
    devils.forEach(d => {
      if (!d.alive) return;
      const ddx = d.x - bx1, ddy = d.y - by1;
      const proj = (ddx * bdx + ddy * bdy) / (bLen * bLen);
      if (proj < 0 || proj > 1) return;
      const closestX = bx1 + proj * bdx;
      const closestY = by1 + proj * bdy;
      const distToBeam = Math.sqrt((d.x - closestX) ** 2 + (d.y - closestY) ** 2);
      if (distToBeam < halfW + d.size * 0.4) {
        d.hit(wp.damage);
        updateScore();
        // Big water burst on hit
        for (let p = 0; p < 8; p++) {
          particles.push({
            x: d.x, y: d.y,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 20 + Math.random() * 15,
            maxLife: 35,
            color: Math.random() < 0.5 ? '#50c8ff' : '#fff',
            size: 3 + Math.random() * 4
          });
        }
      }
    });
    // Beam also explodes balloons in path
    for (let b = balloons.length - 1; b >= 0; b--) {
      const bl = balloons[b];
      const bldx = bl.x - bx1, bldy = bl.y - by1;
      const proj = (bldx * bdx + bldy * bdy) / (bLen * bLen);
      if (proj < 0 || proj > 1) continue;
      const closestX = bx1 + proj * bdx;
      const closestY = by1 + proj * bdy;
      const distToBeam = Math.sqrt((bl.x - closestX) ** 2 + (bl.y - closestY) ** 2);
      if (distToBeam < halfW + bl.size) {
        // Explode this balloon - inline since helper is in game loop
        const expR = bl.explosionRadius;
        devils.forEach(d => {
          if (!d.alive) return;
          const edx = d.x - bl.x, edy = d.y - bl.y;
          const eDist = Math.sqrt(edx * edx + edy * edy);
          if (eDist < expR + d.size * 0.5) { d.hit(bl.damage); updateScore(); }
        });
        balloonExplosions.push({ x: bl.x, y: bl.y, radius: expR, timer: 0, maxTimer: 20, color: bl.color });
        for (let p = 0; p < 20; p++) {
          const ang = Math.random() * Math.PI * 2;
          const spd = 2 + Math.random() * 5;
          particles.push({ x: bl.x, y: bl.y, vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd - 2, life: 15 + Math.random() * 15, maxLife: 30, color: Math.random() < 0.4 ? '#fff' : bl.color, size: 2 + Math.random() * 4 });
        }
        balloons.splice(b, 1);
      }
    }
  } else if (currentWeapon === 5) {
    // Balonek
    const wp = weapons[5];
    if (water < wp.waterCost) { waterFlashTimer = 0; return; }
    water -= wp.waterCost;
    balloons.push(new Balloon(mouseX, mouseY));
  }
}

// Process all input once per frame
function processInput() {
  applyMouseDeltas();
  if (keysJustPressed['1']) { currentWeapon = 0; weaponSwitchTimer = 30; }
  if (keysJustPressed['2']) { currentWeapon = 1; weaponSwitchTimer = 30; }
  if (keysJustPressed['3']) { currentWeapon = 2; weaponSwitchTimer = 30; }
  if (keysJustPressed['q']) { currentWeapon = 3; weaponSwitchTimer = 30; }
  if (keysJustPressed['w']) { currentWeapon = 4; weaponSwitchTimer = 30; }
  if (keysJustPressed['e']) { currentWeapon = 5; weaponSwitchTimer = 30; }
  // Kropenka auto-fire while mouse held
  if (currentWeapon === 2 && mouseHeld && !kropenkaReloading) {
    kropenkaTimer++;
    if (kropenkaTimer >= weapons[2].fireRate) {
      kropenkaTimer = 0;
      if (kropenkaAmmo > 0) {
        kropenkaAmmo--;
        kropenkaBullets.push(new KropenkaBullet(mouseX, mouseY));
      } else {
        weaponSwitchTimer = 15;
      }
    }
  } else {
    kropenkaTimer = 0;
  }
  // Reload selected weapon with spacebar (works even if mag not empty)
  if (keysJustPressed[' ']) {
    if (currentWeapon === 1 && !pistolReloading && pistolAmmo < pistolMagMax) {
      if (water >= pistolReloadWaterCost) {
        pistolReloading = true;
        pistolReloadTimer = 0;
        water -= pistolReloadWaterCost;
      } else { waterFlashTimer = 0; }
    }
    if (currentWeapon === 2 && !kropenkaReloading && kropenkaAmmo < kropenkaMagMax) {
      if (water >= kropenkaReloadWaterCost) {
        kropenkaReloading = true;
        kropenkaReloadTimer = 0;
        water -= kropenkaReloadWaterCost;
      } else { waterFlashTimer = 0; }
    }
  }
  // Prayer activation with Ctrl / Shift
  if (keysJustPressed['control']) { activatePrayer(0); }
  if (keysJustPressed['shift']) { activatePrayer(1); }
  for (const k in keysJustPressed) delete keysJustPressed[k];
}

// Mouse click to shoot + lock pointer + track held state
document.addEventListener('mousedown', (e) => {
  if (e.button === 0) {
    mouseHeld = true;
    if (gameRunning) {
      // Check prayer icon click before shooting
      const pw = 70, ph = 60, pgap = 10;
      for (let pi = 0; pi < prayers.length; pi++) {
        const ppx = W - 90 - pi * (pw + pgap), ppy = H - 90;
        if (mouseX >= ppx && mouseX <= ppx + pw && mouseY >= ppy && mouseY <= ppy + ph) {
          activatePrayer(pi);
          return;
        }
      }
      if (!pointerLocked) lockPointer();
      shoot();
    }
  }
});
document.addEventListener('mouseup', (e) => {
  if (e.button === 0) mouseHeld = false;
});

// Mouse wheel to switch weapons
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  currentWeapon = e.deltaY > 0
    ? (currentWeapon + 1) % weapons.length
    : (currentWeapon - 1 + weapons.length) % weapons.length;
  weaponSwitchTimer = 30;
}, { passive: false });

// Main game loop
function gameLoop() {
  if (!gameRunning) return;

  // Process keyboard input
  processInput();

  // Update prayers
  updatePrayers();

  // Screen shake
  ctx.save();
  if (shakeTimer > 0) {
    shakeTimer--;
    const sx = (Math.random() - 0.5) * shakeIntensity;
    const sy = (Math.random() - 0.5) * shakeIntensity;
    ctx.translate(sx, sy);
    shakeIntensity *= 0.9;
  }

  // Draw scene
  drawSky();
  drawChurch();

  // Refill water
  if (water < waterMax) {
    water = Math.min(waterMax, water + waterRefillRate);
  }

  // Pistol reload tick
  if (pistolReloading) {
    pistolReloadTimer++;
    if (pistolReloadTimer >= pistolReloadTime) {
      pistolReloading = false;
      pistolAmmo = pistolMagMax;
    }
  }
  // Kropenka reload tick
  if (kropenkaReloading) {
    kropenkaReloadTimer++;
    if (kropenkaReloadTimer >= kropenkaReloadTime) {
      kropenkaReloading = false;
      kropenkaAmmo = kropenkaMagMax;
    }
  }

  // Get current wave config
  const wc = waveConfig[Math.min(wave - 1, totalWaves - 1)];

  // Spawn devils (use wave config)
  if (devilsSpawnedInWave < wc.count) {
    spawnTimer++;
    if (spawnTimer >= wc.spawnInterval) {
      spawnTimer = 0;
      devils.push(new Devil(pickEnemyType(wave - 1)));
      devilsSpawnedInWave++;
    }
  }

  // Check wave completion - wave ends when all devils spawned and none alive remain
  // (devils can be killed OR reach the church - either way the wave advances)
  // Angels on screen do NOT block wave transitions
  const allSpawned = devilsSpawnedInWave >= wc.count;
  const noLivingDevils = devils.filter(d => d.alive).length === 0;
  if (allSpawned && noLivingDevils) {
    if (wave >= totalWaves) {
      // Victory!
      gameWon = true;
      gameRunning = false;
      if (pointerLocked) document.exitPointerLock();
      document.getElementById('finalScore').textContent = 'Skore: ' + score;
      const titleEl = document.getElementById('gameOverTitle');
      titleEl.textContent = 'Vitezstvi!';
      titleEl.classList.add('victory');
      document.getElementById('gameOverText').textContent = 'Kostel je zachranen! Vsech 10 vln certu porazeno!';
      document.getElementById('gameOverScreen').style.display = 'flex';
      return;
    }

    wave++;
    devilsKilledInWave = 0;
    devilsSpawnedInWave = 0;
    spawnTimer = 0;
    updateWave();

    // Show wave banner
    const nextWc = waveConfig[wave - 1];
    waveBanner = 'Vlna ' + wave + '/' + totalWaves + ': ' + nextWc.name;
    waveBannerTimer = waveBannerDuration;

    // Wave announcement particle burst
    for (let i = 0; i < 20; i++) {
      particles.push({
        x: W / 2, y: H / 2,
        vx: (Math.random() - 0.5) * 10,
        vy: (Math.random() - 0.5) * 10,
        life: 40 + Math.random() * 20,
        maxLife: 60,
        color: wave >= 8 ? '#ff4444' : '#ffd700',
        size: 3 + Math.random() * 4
      });
    }
  }

  // Wave banner timer
  if (waveBannerTimer > 0) waveBannerTimer--;

  // Angel spawn logic - lower lives = higher chance
  if (angelSpawnCooldown > 0) {
    angelSpawnCooldown--;
  } else if (angels.filter(a => a.alive).length === 0) {
    // Chance scales with missing lives: 0 lives missing = 0.05%, 4 missing = 1.2% per frame
    const missingLives = 5 - lives;
    const spawnChance = 0.0005 + missingLives * 0.003;
    if (Math.random() < spawnChance && lives < 5) {
      angels.push(new Angel());
      angelSpawnCooldown = angelSpawnCooldownMax;
    }
  }

  // Update angels and check devil collisions
  for (let i = angels.length - 1; i >= 0; i--) {
    const angel = angels[i];
    if (!angel.update()) {
      angels.splice(i, 1);
      continue;
    }
    // Check if any devil touches the angel
    if (angel.alive) {
      for (let j = devils.length - 1; j >= 0; j--) {
        if (!devils[j].alive) continue;
        const dx = angel.x - devils[j].x;
        const dy = angel.y - devils[j].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < angel.size * 0.5 + devils[j].size * 0.5) {
          // Devil caught the angel!
          angel.alive = false;
          angel.deathType = 'caught';
          // Dark burst particles
          for (let p = 0; p < 10; p++) {
            particles.push({
              x: angel.x, y: angel.y,
              vx: (Math.random() - 0.5) * 4,
              vy: (Math.random() - 0.5) * 4,
              life: 20 + Math.random() * 15,
              maxLife: 35,
              color: '#666',
              size: 2 + Math.random() * 2
            });
          }
          break;
        }
      }
    }
  }

  // Devils chase nearby angel (divert some towards angel)
  const livingAngel = angels.find(a => a.alive);
  if (livingAngel) {
    devils.forEach(d => {
      if (!d.alive) return;
      const dx = livingAngel.x - d.x;
      const dy = livingAngel.y - d.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      // Devils within range chase the angel
      if (dist < 250) {
        d.x += (dx / dist) * d.speed * 0.4;
        d.y += (dy / dist) * d.speed * 0.4;
      }
    });
  }

  // Helper: explode a balloon at its position (AoE damage + effects)
  function explodeBalloonAt(bl) {
    const expR = bl.explosionRadius;
    shakeTimer = 8;
    shakeIntensity = 4;
    devils.forEach(d => {
      if (!d.alive) return;
      const dx = d.x - bl.x, dy = d.y - bl.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < expR + d.size * 0.5) {
        d.hit(bl.damage);
        updateScore();
      }
    });
    balloonExplosions.push({ x: bl.x, y: bl.y, radius: expR, timer: 0, maxTimer: 20, color: bl.color });
    for (let p = 0; p < 20; p++) {
      const ang = Math.random() * Math.PI * 2;
      const spd = 2 + Math.random() * 5;
      particles.push({
        x: bl.x, y: bl.y,
        vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd - 2,
        life: 15 + Math.random() * 15, maxLife: 30,
        color: Math.random() < 0.4 ? '#fff' : bl.color,
        size: 2 + Math.random() * 4
      });
    }
  }

  // Helper: check if a projectile hits any balloon, returns true if projectile should be removed
  function checkProjectileVsBalloons(px, py, pSize) {
    for (let b = balloons.length - 1; b >= 0; b--) {
      const bl = balloons[b];
      const dx = px - bl.x, dy = py - bl.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < bl.size + pSize) {
        explodeBalloonAt(bl);
        balloons.splice(b, 1);
        return true;
      }
    }
    return false;
  }

  // Update and draw holy water
  for (let i = holyWaters.length - 1; i >= 0; i--) {
    const hw = holyWaters[i];
    if (!hw.update()) {
      holyWaters.splice(i, 1);
      continue;
    }

    // Check collision with balloons
    if (checkProjectileVsBalloons(hw.x, hw.y, weapons[0].size)) {
      holyWaters.splice(i, 1);
      continue;
    }
    // Check collisions with devils
    for (let j = devils.length - 1; j >= 0; j--) {
      if (devils[j].alive && hw.checkCollision(devils[j])) {
        splashes.push(new Splash(hw.x, hw.y));
        devils[j].hit(weapons[0].damage);
        holyWaters.splice(i, 1);
        updateScore();
        break;
      }
    }
  }

  // Update and check pistol bullets
  for (let i = pistolBullets.length - 1; i >= 0; i--) {
    const pb = pistolBullets[i];
    if (!pb.update()) {
      pistolBullets.splice(i, 1);
      continue;
    }
    // Check collision with balloons
    if (checkProjectileVsBalloons(pb.x, pb.y, weapons[1].size)) {
      pistolBullets.splice(i, 1);
      continue;
    }
    for (let j = devils.length - 1; j >= 0; j--) {
      if (devils[j].alive && pb.checkCollision(devils[j])) {
        // Small splash for pistol
        splashes.push(new Splash(pb.x, pb.y));
        devils[j].hit(pb.damage);
        pistolBullets.splice(i, 1);
        updateScore();
        break;
      }
    }
  }

  // Update and check spray drops
  for (let i = sprayDrops.length - 1; i >= 0; i--) {
    const sd = sprayDrops[i];
    if (!sd.update()) {
      sprayDrops.splice(i, 1);
      continue;
    }
    // Check collision with balloons
    if (checkProjectileVsBalloons(sd.x, sd.y, weapons[3].size || 2)) {
      sprayDrops.splice(i, 1);
      continue;
    }
    for (let j = devils.length - 1; j >= 0; j--) {
      if (devils[j].alive && sd.checkCollision(devils[j])) {
        devils[j].hit(sd.damage);
        // Small particles instead of full splash
        particles.push({
          x: sd.x, y: sd.y,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 0.5) * 3,
          life: 10 + Math.random() * 10,
          maxLife: 20,
          color: '#a0d8ef',
          size: 2 + Math.random() * 2
        });
        sprayDrops.splice(i, 1);
        updateScore();
        break;
      }
    }
  }

  // Update and check kropenka bullets
  for (let i = kropenkaBullets.length - 1; i >= 0; i--) {
    const kb = kropenkaBullets[i];
    if (!kb.update()) {
      kropenkaBullets.splice(i, 1);
      continue;
    }
    // Check collision with balloons
    if (checkProjectileVsBalloons(kb.x, kb.y, weapons[2].size)) {
      kropenkaBullets.splice(i, 1);
      continue;
    }
    for (let j = devils.length - 1; j >= 0; j--) {
      if (devils[j].alive && kb.checkCollision(devils[j])) {
        devils[j].hit(kb.damage);
        particles.push({
          x: kb.x, y: kb.y,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          life: 8 + Math.random() * 6,
          maxLife: 14,
          color: '#90d0f0',
          size: 1.5 + Math.random() * 1.5
        });
        kropenkaBullets.splice(i, 1);
        updateScore();
        break;
      }
    }
  }

  // Update and check balloons
  for (let i = balloons.length - 1; i >= 0; i--) {
    const bl = balloons[i];
    if (!bl.update()) {
      balloons.splice(i, 1);
      continue;
    }
    // Check collision with any devil
    let exploded = false;
    for (let j = 0; j < devils.length; j++) {
      if (devils[j].alive && bl.checkCollision(devils[j])) {
        exploded = true;
        break;
      }
    }
    if (exploded) {
      explodeBalloonAt(bl);
      balloons.splice(i, 1);
    }
  }

  // Update balloon explosions
  for (let i = balloonExplosions.length - 1; i >= 0; i--) {
    balloonExplosions[i].timer++;
    if (balloonExplosions[i].timer >= balloonExplosions[i].maxTimer) {
      balloonExplosions.splice(i, 1);
    }
  }

  // ======== BEAM FLASH UPDATE ========
  if (beamFlash) {
    beamFlash.timer++;
    if (beamFlash.timer >= beamFlash.maxTimer) {
      beamFlash = null;
    }
  }

  // Update devils
  for (let i = devils.length - 1; i >= 0; i--) {
    if (!devils[i].update()) {
      if (devils[i].alive) {
        // Devil reached church
        shakeTimer = 20;
        shakeIntensity = 10;
      }
      devils.splice(i, 1);
    }
  }

  // Draw beam flash (fading single-shot beam)
  if (beamFlash) {
    const bf = beamFlash;
    const progress = bf.timer / bf.maxTimer; // 0 -> 1
    const alpha = 1 - progress;
    const bw = weapons[4].beamWidth * (1 + progress * 0.5); // slightly expands as it fades

    // Outer glow
    ctx.save();
    ctx.globalAlpha = alpha * 0.2;
    ctx.strokeStyle = '#80d0ff';
    ctx.lineWidth = bw * 3;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(bf.x1, bf.y1);
    ctx.lineTo(bf.x2, bf.y2);
    ctx.stroke();
    ctx.restore();

    // Middle glow
    ctx.save();
    ctx.globalAlpha = alpha * 0.5;
    ctx.strokeStyle = '#60c0ff';
    ctx.lineWidth = bw * 1.8;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(bf.x1, bf.y1);
    ctx.lineTo(bf.x2, bf.y2);
    ctx.stroke();
    ctx.restore();

    // Core beam
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = '#c0eaff';
    ctx.shadowColor = '#50c8ff';
    ctx.shadowBlur = 20 * alpha;
    ctx.lineWidth = bw;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(bf.x1, bf.y1);
    ctx.lineTo(bf.x2, bf.y2);
    ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.restore();

    // White core
    ctx.save();
    ctx.globalAlpha = alpha * 0.8;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = bw * 0.3;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(bf.x1, bf.y1);
    ctx.lineTo(bf.x2, bf.y2);
    ctx.stroke();
    ctx.restore();
  }

  // Draw devils
  devils.forEach(d => d.draw());

  // Draw lightning bolts
  drawLightningBolts();

  // Draw angels
  angels.forEach(a => a.draw());

  // Draw holy water
  holyWaters.forEach(hw => hw.draw());

  // Draw pistol bullets
  pistolBullets.forEach(pb => pb.draw());

  // Draw spray drops
  sprayDrops.forEach(sd => sd.draw());

  // Draw kropenka bullets
  kropenkaBullets.forEach(kb => kb.draw());

  // Draw balloons
  balloons.forEach(bl => bl.draw());

  // Draw balloon explosions
  balloonExplosions.forEach(exp => {
    const progress = exp.timer / exp.maxTimer;
    const expandProgress = Math.min(1, progress * 2); // expands fast
    const fadeProgress = Math.max(0, (progress - 0.3) / 0.7); // fades later
    const r = exp.radius * expandProgress;
    // Outer ring
    ctx.beginPath();
    ctx.arc(exp.x, exp.y, r, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(77,166,255,${(1 - fadeProgress) * 0.6})`;
    ctx.lineWidth = 3;
    ctx.stroke();
    // Inner fill
    ctx.beginPath();
    ctx.arc(exp.x, exp.y, r * 0.9, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(100,190,255,${(1 - fadeProgress) * 0.2})`;
    ctx.fill();
    // Core flash
    if (progress < 0.3) {
      ctx.beginPath();
      ctx.arc(exp.x, exp.y, r * 0.4 * (1 - progress / 0.3), 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255,255,255,${(1 - progress / 0.3) * 0.7})`;
      ctx.fill();
    }
    // Water droplet ring
    const dropCount = 8;
    for (let d = 0; d < dropCount; d++) {
      const ang = (d / dropCount) * Math.PI * 2 + progress * 2;
      const dr = r * (0.5 + expandProgress * 0.5);
      const dx = exp.x + Math.cos(ang) * dr;
      const dy = exp.y + Math.sin(ang) * dr;
      ctx.beginPath();
      ctx.arc(dx, dy, 3 * (1 - fadeProgress), 0, Math.PI * 2);
      ctx.fillStyle = `rgba(150,210,255,${(1 - fadeProgress) * 0.5})`;
      ctx.fill();
    }
  });

  // Draw and update splashes
  for (let i = splashes.length - 1; i >= 0; i--) {
    if (!splashes[i].update()) {
      splashes.splice(i, 1);
    } else {
      splashes[i].draw();
    }
  }

  // Update and draw particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1;
    p.life--;
    if (p.life <= 0) {
      particles.splice(i, 1);
    } else {
      const alpha = p.life / p.maxLife;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.globalAlpha = alpha;
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  ctx.restore(); // End shake

  // Draw HUD (outside shake so it stays stable)
  drawWaterTank();
  drawWeaponHUD();
  drawPrayerHUD();
  drawWaveBanner();

  // Draw custom crosshair cursor
  const cx = mouseX, cy = mouseY;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.shadowColor = '#7ec8f0';
  ctx.shadowBlur = 6;
  // Outer cross lines
  ctx.beginPath();
  ctx.moveTo(cx - 14, cy); ctx.lineTo(cx - 5, cy);
  ctx.moveTo(cx + 5, cy); ctx.lineTo(cx + 14, cy);
  ctx.moveTo(cx, cy - 14); ctx.lineTo(cx, cy - 5);
  ctx.moveTo(cx, cy + 5); ctx.lineTo(cx, cy + 14);
  ctx.stroke();
  // Center dot
  ctx.fillStyle = '#ffd700';
  ctx.beginPath();
  ctx.arc(cx, cy, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Check game over
  if (lives <= 0) {
    gameRunning = false;
    if (pointerLocked) document.exitPointerLock();
    document.getElementById('finalScore').textContent = 'Skore: ' + score + ' (Vlna ' + wave + '/' + totalWaves + ')';
    const titleEl2 = document.getElementById('gameOverTitle');
    titleEl2.textContent = 'Konec hry!';
    titleEl2.classList.remove('victory');
    document.getElementById('gameOverText').textContent = 'Certi ovladli kostel ve vlne ' + wave + '...';
    document.getElementById('gameOverScreen').style.display = 'flex';
    return;
  }

  updateLives();
  requestAnimationFrame(gameLoop);
}

// Start / Restart
function startGame() {
  score = 0; lives = 5; wave = 1; water = waterMax; currentWeapon = 0;
  gameWon = false; initPrayerStates();
  lightningBolts = []; lightningBoltTimer = 0;
  pistolAmmo = pistolMagMax; pistolReloading = false; pistolReloadTimer = 0;
  beamFlash = null; mouseHeld = false;
  kropenkaBullets = []; kropenkaTimer = 0;
  kropenkaAmmo = kropenkaMagMax; kropenkaReloading = false; kropenkaReloadTimer = 0;
  balloons = []; balloonExplosions = [];
  angels = []; angelSpawnCooldown = 0;
  devils = []; holyWaters = []; splashes = []; particles = []; pistolBullets = []; sprayDrops = [];
  devilsKilledInWave = 0;
  spawnTimer = 0; devilsSpawnedInWave = 0;
  gameRunning = true;
  mouseX = W / 2; mouseY = H / 2;
  moveDeltaX = 0; moveDeltaY = 0;
  for (const k in keysDown) keysDown[k] = false;
  for (const k in keysJustPressed) delete keysJustPressed[k];
  lockPointer();
  // Show first wave banner
  waveBanner = 'Vlna 1/' + totalWaves + ': ' + waveConfig[0].name;
  waveBannerTimer = waveBannerDuration;
  updateScore(); updateWave(); updateLives();
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameOverScreen').style.display = 'none';
  requestAnimationFrame(gameLoop);
}

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', startGame);

// Initial draw
drawSky();
drawChurch();
</script>
</body>
</html>
