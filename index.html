<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Svecena Voda vs Certi</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #000; font-family: 'Segoe UI', Arial, sans-serif; }
canvas { display: block; cursor: none; outline: none; }
#ui {
  position: absolute; top: 0; left: 0; width: 100%; padding: 10px 20px;
  display: flex; justify-content: space-between; align-items: center;
  pointer-events: none; z-index: 10;
}
#ui > div { pointer-events: auto; }
.hud-text {
  color: #ffd700; font-size: 20px; font-weight: bold;
  text-shadow: 2px 2px 4px #000, 0 0 10px rgba(255,215,0,0.5);
}
#startScreen, #gameOverScreen {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  background: rgba(0,0,0,0.85); z-index: 20; color: #fff;
}
#startScreen h1, #gameOverScreen h1 {
  font-size: 48px; color: #ffd700; margin-bottom: 10px;
  text-shadow: 0 0 20px rgba(255,215,0,0.6);
}
#startScreen p, #gameOverScreen p {
  font-size: 18px; color: #ccc; margin-bottom: 30px; text-align: center; line-height: 1.6;
}
.btn {
  padding: 15px 40px; font-size: 22px; background: linear-gradient(180deg, #ffd700, #b8860b);
  border: 2px solid #ffd700; color: #1a0a00; font-weight: bold; cursor: pointer;
  border-radius: 8px; transition: transform 0.2s, box-shadow 0.2s;
}
.btn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(255,215,0,0.6); }
#finalScore { font-size: 36px; color: #ffd700; margin: 10px 0 20px; }
#gameOverTitle.victory {
  color: #ffd700;
  text-shadow: 0 0 30px rgba(255,215,0,0.8), 0 0 60px rgba(255,215,0,0.4);
  animation: victoryPulse 1.5s ease-in-out infinite;
}
@keyframes victoryPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="ui">
  <div class="hud-text" id="scoreDisplay">Skore: 0</div>
  <div class="hud-text" id="waveDisplay">Vlna: 1</div>
  <div class="hud-text" id="livesDisplay"></div>
</div>

<div id="startScreen">
  <h1>Svecena Voda vs Certi</h1>
  <p>Branis kostel pred hordy letajicich certu!<br>
  Klikni do hry pro zachyceni mysi. Strilej kliknutim nebo mezernikem.<br>
  Prepinaj zbrane klavesami Q/W/E/F nebo koleckem mysi.<br>
  Pistolka ma zasobnik na 20 ran - dobij klavesou R (stoji 50% vody).<br>
  Nenech certy doletit ke kostelu!</p>
  <button class="btn" id="startBtn">Hrat</button>
</div>

<div id="gameOverScreen" style="display:none;">
  <h1 id="gameOverTitle">Konec hry!</h1>
  <p id="gameOverText">Certi ovladli kostel...</p>
  <div id="finalScore">0</div>
  <button class="btn" id="restartBtn">Hrat znovu</button>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Game state
let score = 0;
let lives = 5;
let wave = 1;
let devils = [];
let splashes = [];
let holyWaters = [];
let particles = [];
let stars = [];
let gameRunning = false;
let devilsKilledInWave = 0;
let devilsPerWave = 5;
let spawnTimer = 0;
let spawnInterval = 120;
let devilsSpawnedInWave = 0;
let crossGlow = 0;
let gameWon = false;

// Wave definitions (10 waves)
const waveConfig = [
  // { count, spawnInterval, minHp, maxHp, minSpeed, maxSpeed, minSize, maxSize, name }
  { count: 5,  spawnInterval: 130, minHp: 1, maxHp: 1, minSpeed: 0.7, maxSpeed: 1.0, minSize: 28, maxSize: 36, name: 'Prvni horda' },
  { count: 7,  spawnInterval: 110, minHp: 1, maxHp: 1, minSpeed: 0.8, maxSpeed: 1.2, minSize: 28, maxSize: 38, name: 'Posily z pekla' },
  { count: 9,  spawnInterval: 100, minHp: 1, maxHp: 2, minSpeed: 0.9, maxSpeed: 1.3, minSize: 30, maxSize: 40, name: 'Tuzsi korist' },
  { count: 11, spawnInterval: 90,  minHp: 1, maxHp: 2, minSpeed: 1.0, maxSpeed: 1.5, minSize: 30, maxSize: 42, name: 'Pekelny pruval' },
  { count: 13, spawnInterval: 80,  minHp: 1, maxHp: 3, minSpeed: 1.0, maxSpeed: 1.6, minSize: 32, maxSize: 44, name: 'Certuv regiment' },
  { count: 15, spawnInterval: 70,  minHp: 2, maxHp: 3, minSpeed: 1.1, maxSpeed: 1.7, minSize: 32, maxSize: 44, name: 'Temnota houstne' },
  { count: 18, spawnInterval: 60,  minHp: 2, maxHp: 3, minSpeed: 1.2, maxSpeed: 1.8, minSize: 34, maxSize: 46, name: 'Nebeska zkouska' },
  { count: 20, spawnInterval: 55,  minHp: 2, maxHp: 4, minSpeed: 1.3, maxSpeed: 2.0, minSize: 34, maxSize: 48, name: 'Pekelna ofenziva' },
  { count: 24, spawnInterval: 45,  minHp: 2, maxHp: 4, minSpeed: 1.4, maxSpeed: 2.2, minSize: 36, maxSize: 50, name: 'Satanuv hnev' },
  { count: 30, spawnInterval: 35,  minHp: 3, maxHp: 5, minSpeed: 1.5, maxSpeed: 2.5, minSize: 38, maxSize: 55, name: 'Finalni bitva!' },
];
const totalWaves = waveConfig.length;

// Wave announcement banner
let waveBanner = '';
let waveBannerTimer = 0;
const waveBannerDuration = 120; // 2 seconds
let shakeTimer = 0;
let shakeIntensity = 0;

// Water tank
const waterMax = 100;
let water = waterMax;
const waterRefillRate = 0.15; // per frame
let waterFlashTimer = 0; // flash red when empty

// Weapons system
const weapons = [
  { name: 'Svecena voda', key: 'Q', waterCost: 12, damage: 1, speed: 10, size: 8, color: '#7ec8f0', trailColor: 'rgba(100,180,255,', gravity: 0.05, piercing: false },
  { name: 'Pistolka', key: 'W', waterCost: 0, damage: 0.5, speed: 18, size: 4, color: '#b0e0ff', trailColor: 'rgba(170,220,255,', gravity: 0.01, piercing: false },
  { name: 'Sprej', key: 'E', waterCost: 20, damage: 0.25, speed: 12, size: 2, dropCount: 16, spreadAngle: 60, color: '#a0d8ef', gravity: 0.08, piercing: false },
  { name: 'Svaty proud', key: 'F', waterCost: 20, damage: 2, beam: true, beamWidth: 14, color: '#50c8ff', piercing: true }
];
let currentWeapon = 0;
let pistolBullets = [];
let sprayDrops = [];
let weaponSwitchTimer = 0; // for HUD animation

// Pistol magazine
const pistolMagMax = 20;
let pistolAmmo = pistolMagMax;
let pistolReloading = false;
let pistolReloadTimer = 0;
const pistolReloadTime = 90; // frames (~1.5s at 60fps)
const pistolReloadWaterCost = 50;

// Beam weapon state
let beamActive = false;
let beamDamageTimer = 0; // counts up, deals damage every 60 frames (1s)
let beamWaterTimer = 0; // counts up, drains water every 60 frames (1s)
const beamDamageInterval = 60; // frames = 1s
const beamWaterInterval = 60; // frames = 1s
let beamPhase = 0; // visual animation phase
let mouseHeld = false; // is mouse/spacebar being held

// Input tracking
let mouseX = 0;
let mouseY = 0;
const keysDown = {};
const keysJustPressed = {};

// Angel system
let angels = [];
let angelSpawnCooldown = 0;
const angelSpawnCooldownMax = 300; // min frames between angel spawns

// Generate stars
function generateStars() {
  stars = [];
  for (let i = 0; i < 100; i++) {
    stars.push({
      x: Math.random() * W,
      y: Math.random() * H * 0.5,
      size: Math.random() * 2 + 0.5,
      twinkle: Math.random() * Math.PI * 2,
      speed: Math.random() * 0.02 + 0.01
    });
  }
}
generateStars();

// Church drawing
function drawChurch() {
  const cx = W / 2;
  const groundY = H - 60;

  // Ground
  const grd = ctx.createLinearGradient(0, groundY - 20, 0, H);
  grd.addColorStop(0, '#2d5016');
  grd.addColorStop(1, '#1a3009');
  ctx.fillStyle = grd;
  ctx.fillRect(0, groundY - 20, W, H - groundY + 20);

  // Church body
  const bw = 220, bh = 200;
  const bx = cx - bw / 2, by = groundY - bh;

  const wallGrd = ctx.createLinearGradient(bx, by, bx + bw, by);
  wallGrd.addColorStop(0, '#8B7355');
  wallGrd.addColorStop(0.5, '#A0896C');
  wallGrd.addColorStop(1, '#7A6548');
  ctx.fillStyle = wallGrd;
  ctx.fillRect(bx, by, bw, bh);

  // Stone lines
  ctx.strokeStyle = 'rgba(0,0,0,0.15)';
  ctx.lineWidth = 1;
  for (let row = 0; row < 8; row++) {
    const ry = by + row * 25;
    ctx.beginPath(); ctx.moveTo(bx, ry); ctx.lineTo(bx + bw, ry); ctx.stroke();
    const offset = row % 2 === 0 ? 0 : 35;
    for (let col = offset; col < bw; col += 70) {
      ctx.beginPath(); ctx.moveTo(bx + col, ry); ctx.lineTo(bx + col, ry + 25); ctx.stroke();
    }
  }

  // Roof
  ctx.fillStyle = '#4a3728';
  ctx.beginPath();
  ctx.moveTo(bx - 20, by);
  ctx.lineTo(cx, by - 100);
  ctx.lineTo(bx + bw + 20, by);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = '#3a2718';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Tower
  const tw = 60, th = 140;
  const tx = cx - tw / 2, ty = by - 100 - th + 40;
  ctx.fillStyle = '#9B8B75';
  ctx.fillRect(tx, ty, tw, th);

  // Tower roof
  ctx.fillStyle = '#4a3728';
  ctx.beginPath();
  ctx.moveTo(tx - 10, ty);
  ctx.lineTo(cx, ty - 60);
  ctx.lineTo(tx + tw + 10, ty);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Cross on top
  crossGlow = (crossGlow + 0.03) % (Math.PI * 2);
  const glowAlpha = 0.3 + Math.sin(crossGlow) * 0.2;
  ctx.shadowColor = '#ffd700';
  ctx.shadowBlur = 15 + Math.sin(crossGlow) * 10;
  ctx.strokeStyle = '#ffd700';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(cx, ty - 60); ctx.lineTo(cx, ty - 90);
  ctx.moveTo(cx - 12, ty - 78); ctx.lineTo(cx + 12, ty - 78);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Glow circle around cross
  ctx.beginPath();
  ctx.arc(cx, ty - 75, 25, 0, Math.PI * 2);
  ctx.fillStyle = `rgba(255,215,0,${glowAlpha * 0.3})`;
  ctx.fill();

  // Window - rose window
  ctx.beginPath();
  ctx.arc(cx, by + 50, 30, 0, Math.PI * 2);
  ctx.fillStyle = '#1a0a30';
  ctx.fill();
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 3;
  ctx.stroke();
  // Rose window spokes
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2;
    ctx.beginPath();
    ctx.moveTo(cx, by + 50);
    ctx.lineTo(cx + Math.cos(angle) * 28, by + 50 + Math.sin(angle) * 28);
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }
  // Inner glow
  const rGrd = ctx.createRadialGradient(cx, by + 50, 0, cx, by + 50, 28);
  rGrd.addColorStop(0, 'rgba(100,50,150,0.4)');
  rGrd.addColorStop(0.5, 'rgba(50,20,100,0.2)');
  rGrd.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = rGrd;
  ctx.beginPath();
  ctx.arc(cx, by + 50, 28, 0, Math.PI * 2);
  ctx.fill();

  // Side windows
  for (let i = -1; i <= 1; i += 2) {
    const wx = cx + i * 65;
    ctx.fillStyle = '#1a0a30';
    ctx.fillRect(wx - 12, by + 80, 24, 50);
    ctx.beginPath();
    ctx.arc(wx, by + 80, 12, Math.PI, 0);
    ctx.fill();
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.strokeRect(wx - 12, by + 80, 24, 50);
    ctx.beginPath();
    ctx.arc(wx, by + 80, 12, Math.PI, 0);
    ctx.stroke();
    // Yellow glow from inside
    const wGrd = ctx.createRadialGradient(wx, by + 100, 0, wx, by + 100, 20);
    wGrd.addColorStop(0, 'rgba(255,200,50,0.3)');
    wGrd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = wGrd;
    ctx.fillRect(wx - 12, by + 80, 24, 50);
  }

  // Door
  ctx.fillStyle = '#3a2000';
  ctx.fillRect(cx - 22, by + 150, 44, 50);
  ctx.beginPath();
  ctx.arc(cx, by + 150, 22, Math.PI, 0);
  ctx.fill();
  ctx.strokeStyle = '#2a1500';
  ctx.lineWidth = 2;
  ctx.strokeRect(cx - 22, by + 150, 44, 50);
  ctx.beginPath();
  ctx.arc(cx, by + 150, 22, Math.PI, 0);
  ctx.stroke();

  // Door handle
  ctx.beginPath();
  ctx.arc(cx + 10, by + 175, 3, 0, Math.PI * 2);
  ctx.fillStyle = '#b8860b';
  ctx.fill();
}

// Sky gradient
function drawSky() {
  const grd = ctx.createLinearGradient(0, 0, 0, H);
  grd.addColorStop(0, '#0a0020');
  grd.addColorStop(0.4, '#1a0040');
  grd.addColorStop(0.7, '#2a1050');
  grd.addColorStop(1, '#150030');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, W, H);

  // Moon
  ctx.beginPath();
  ctx.arc(W * 0.8, H * 0.12, 40, 0, Math.PI * 2);
  ctx.fillStyle = '#ffe8b0';
  ctx.shadowColor = '#ffe8b0';
  ctx.shadowBlur = 40;
  ctx.fill();
  ctx.shadowBlur = 0;
  // Moon crater
  ctx.beginPath();
  ctx.arc(W * 0.8 - 10, H * 0.12 - 5, 35, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(10,0,30,0.15)';
  ctx.fill();

  // Stars
  stars.forEach(s => {
    s.twinkle += s.speed;
    const alpha = 0.4 + Math.sin(s.twinkle) * 0.4;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,220,${alpha})`;
    ctx.fill();
  });
}

// Devil class
class Devil {
  constructor() {
    const wc = waveConfig[Math.min(wave - 1, totalWaves - 1)];
    this.size = wc.minSize + Math.random() * (wc.maxSize - wc.minSize);
    this.hp = wc.minHp + Math.floor(Math.random() * (wc.maxHp - wc.minHp + 1));
    this.maxHp = this.hp;
    this.speed = wc.minSpeed + Math.random() * (wc.maxSpeed - wc.minSpeed);

    // Spawn from sides or top
    const side = Math.random();
    if (side < 0.4) {
      this.x = -this.size;
      this.y = Math.random() * H * 0.5 + 50;
    } else if (side < 0.8) {
      this.x = W + this.size;
      this.y = Math.random() * H * 0.5 + 50;
    } else {
      this.x = Math.random() * W;
      this.y = -this.size;
    }

    this.targetX = W / 2 + (Math.random() - 0.5) * 200;
    this.targetY = H - 260 + Math.random() * 80;
    this.wingAngle = 0;
    this.wobble = Math.random() * Math.PI * 2;
    this.wobbleSpeed = 0.03 + Math.random() * 0.02;
    this.alive = true;
    this.deathTimer = 0;
    this.flashTimer = 0;
    this.color = `hsl(${Math.random() * 30 + 350}, 80%, ${30 + Math.random() * 20}%)`;
    this.hornSize = 8 + Math.random() * 6;
  }

  update() {
    if (!this.alive) {
      this.deathTimer++;
      this.y += 3;
      return this.deathTimer < 30;
    }

    this.wobble += this.wobbleSpeed;
    this.wingAngle = Math.sin(this.wobble * 3) * 0.5;

    const dx = this.targetX - this.x + Math.sin(this.wobble) * 40;
    const dy = this.targetY - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > 5) {
      this.x += (dx / dist) * this.speed;
      this.y += (dy / dist) * this.speed;
    } else {
      // Reached the church - damage!
      lives--;
      shakeTimer = 15;
      shakeIntensity = 8;
      updateLives();
      return false;
    }

    if (this.flashTimer > 0) this.flashTimer--;
    return true;
  }

  draw() {
    const s = this.size;
    const alpha = this.alive ? 1 : (1 - this.deathTimer / 30);

    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.globalAlpha = alpha;

    if (this.flashTimer > 0) {
      ctx.shadowColor = '#fff';
      ctx.shadowBlur = 20;
    }

    // Wings
    ctx.fillStyle = this.alive ? 'rgba(80,0,0,0.7)' : 'rgba(80,0,0,0.3)';
    // Left wing
    ctx.save();
    ctx.rotate(-0.3 + this.wingAngle);
    ctx.beginPath();
    ctx.moveTo(-5, -5);
    ctx.quadraticCurveTo(-s * 1.2, -s * 0.8, -s * 0.8, 5);
    ctx.quadraticCurveTo(-s * 0.5, -5, -5, 0);
    ctx.fill();
    ctx.restore();
    // Right wing
    ctx.save();
    ctx.rotate(0.3 - this.wingAngle);
    ctx.beginPath();
    ctx.moveTo(5, -5);
    ctx.quadraticCurveTo(s * 1.2, -s * 0.8, s * 0.8, 5);
    ctx.quadraticCurveTo(s * 0.5, -5, 5, 0);
    ctx.fill();
    ctx.restore();

    // Body
    ctx.fillStyle = this.flashTimer > 0 ? '#fff' : this.color;
    ctx.beginPath();
    ctx.ellipse(0, 0, s * 0.4, s * 0.55, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head
    ctx.beginPath();
    ctx.arc(0, -s * 0.5, s * 0.3, 0, Math.PI * 2);
    ctx.fill();

    // Horns
    ctx.strokeStyle = '#1a0000';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-s * 0.15, -s * 0.7);
    ctx.quadraticCurveTo(-s * 0.4, -s * 1.1, -s * 0.1, -s * 0.95);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(s * 0.15, -s * 0.7);
    ctx.quadraticCurveTo(s * 0.4, -s * 1.1, s * 0.1, -s * 0.95);
    ctx.stroke();

    // Eyes
    ctx.fillStyle = '#ff0';
    ctx.beginPath();
    ctx.arc(-s * 0.1, -s * 0.5, 4, 0, Math.PI * 2);
    ctx.arc(s * 0.1, -s * 0.5, 4, 0, Math.PI * 2);
    ctx.fill();
    // Pupils
    ctx.fillStyle = '#f00';
    ctx.beginPath();
    ctx.arc(-s * 0.1, -s * 0.5, 2, 0, Math.PI * 2);
    ctx.arc(s * 0.1, -s * 0.5, 2, 0, Math.PI * 2);
    ctx.fill();

    // Mouth
    ctx.strokeStyle = '#ff3300';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, -s * 0.38, 6, 0, Math.PI);
    ctx.stroke();

    // Tail
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, s * 0.5);
    ctx.quadraticCurveTo(s * 0.4, s * 0.8, s * 0.2, s * 0.9);
    ctx.stroke();
    // Tail tip (arrow)
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(s * 0.2, s * 0.85);
    ctx.lineTo(s * 0.35, s * 0.95);
    ctx.lineTo(s * 0.15, s * 1.0);
    ctx.closePath();
    ctx.fill();

    // HP bar (show when damaged or tough devil)
    if ((this.hp < this.maxHp || this.maxHp > 1) && this.alive) {
      ctx.fillStyle = '#333';
      ctx.fillRect(-15, -s * 0.95 - 12, 30, 5);
      const hpRatio = Math.max(0, this.hp / this.maxHp);
      ctx.fillStyle = hpRatio > 0.5 ? '#0f0' : hpRatio > 0.25 ? '#ff0' : '#f00';
      ctx.fillRect(-15, -s * 0.95 - 12, 30 * hpRatio, 5);
    }

    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.restore();
  }

  hit(damage = 1) {
    this.hp -= damage;
    this.flashTimer = 5;
    if (this.hp <= 0) {
      this.alive = false;
      score += this.maxHp * 10;
      devilsKilledInWave++;
      // Spawn death particles
      for (let i = 0; i < 12; i++) {
        particles.push({
          x: this.x, y: this.y,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6,
          life: 30 + Math.random() * 20,
          maxLife: 50,
          color: `hsl(${Math.random() * 30}, 90%, 50%)`,
          size: 3 + Math.random() * 4
        });
      }
      return true;
    }
    return false;
  }
}

// Holy water projectile
class HolyWater {
  constructor(x, y, tx, ty) {
    this.x = W / 2;
    this.y = H - 200;
    const dx = tx - this.x;
    const dy = ty - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const speed = 10;
    this.vx = (dx / dist) * speed;
    this.vy = (dy / dist) * speed;
    this.life = 100;
    this.size = 8;
    this.trail = [];
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.05; // slight gravity
    this.life--;

    this.trail.push({ x: this.x, y: this.y, life: 15 });
    if (this.trail.length > 10) this.trail.shift();
    this.trail.forEach(t => t.life--);

    return this.life > 0 && this.x > -20 && this.x < W + 20 && this.y > -20 && this.y < H + 20;
  }

  draw() {
    // Trail
    this.trail.forEach(t => {
      const alpha = t.life / 15;
      ctx.beginPath();
      ctx.arc(t.x, t.y, 3 * alpha, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(100,180,255,${alpha * 0.5})`;
      ctx.fill();
    });

    // Holy water drop
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fillStyle = '#7ec8f0';
    ctx.shadowColor = '#aae0ff';
    ctx.shadowBlur = 15;
    ctx.fill();
    ctx.shadowBlur = 0;

    // Cross symbol on the drop
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.x, this.y - 4);
    ctx.lineTo(this.x, this.y + 4);
    ctx.moveTo(this.x - 3, this.y - 1);
    ctx.lineTo(this.x + 3, this.y - 1);
    ctx.stroke();
  }

  checkCollision(devil) {
    const dx = this.x - devil.x;
    const dy = this.y - devil.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    return dist < devil.size * 0.6 + this.size;
  }
}

// Splash effect
class Splash {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.timer = 0;
    this.maxTimer = 25;
    this.drops = [];
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      this.drops.push({
        x: 0, y: 0,
        vx: Math.cos(angle) * (3 + Math.random() * 3),
        vy: Math.sin(angle) * (3 + Math.random() * 3),
        size: 2 + Math.random() * 3
      });
    }
  }

  update() {
    this.timer++;
    this.drops.forEach(d => {
      d.x += d.vx;
      d.y += d.vy;
      d.vy += 0.15;
    });
    return this.timer < this.maxTimer;
  }

  draw() {
    const alpha = 1 - this.timer / this.maxTimer;
    ctx.globalAlpha = alpha;

    // Central flash
    if (this.timer < 8) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, 20 - this.timer * 2, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(200,230,255,${alpha * 0.5})`;
      ctx.fill();

      // Cross flash
      ctx.strokeStyle = `rgba(255,255,200,${alpha})`;
      ctx.lineWidth = 3;
      const cs = 15 - this.timer;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y - cs);
      ctx.lineTo(this.x, this.y + cs);
      ctx.moveTo(this.x - cs, this.y);
      ctx.lineTo(this.x + cs, this.y);
      ctx.stroke();
    }

    // Drops
    this.drops.forEach(d => {
      ctx.beginPath();
      ctx.arc(this.x + d.x, this.y + d.y, d.size * alpha, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(150,210,255,${alpha})`;
      ctx.fill();
    });

    ctx.globalAlpha = 1;
  }
}

// Pistol bullet projectile
class PistolBullet {
  constructor(tx, ty) {
    this.x = W / 2;
    this.y = H - 200;
    const dx = tx - this.x;
    const dy = ty - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const wp = weapons[1];
    this.vx = (dx / dist) * wp.speed;
    this.vy = (dy / dist) * wp.speed;
    this.life = 80;
    this.size = wp.size;
    this.damage = wp.damage;
    this.trail = [];
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.01;
    this.life--;

    this.trail.push({ x: this.x, y: this.y, life: 8 });
    if (this.trail.length > 6) this.trail.shift();
    this.trail.forEach(t => t.life--);

    return this.life > 0 && this.x > -20 && this.x < W + 20 && this.y > -20 && this.y < H + 20;
  }

  draw() {
    // Trail - thin and fast
    this.trail.forEach(t => {
      const alpha = t.life / 8;
      ctx.beginPath();
      ctx.arc(t.x, t.y, 2 * alpha, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(170,220,255,${alpha * 0.4})`;
      ctx.fill();
    });

    // Bullet glow
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size + 2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(180,220,255,0.3)';
    ctx.fill();

    // Bullet core
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fillStyle = '#b0e0ff';
    ctx.shadowColor = '#ddf0ff';
    ctx.shadowBlur = 8;
    ctx.fill();
    ctx.shadowBlur = 0;

    // Tiny sparkle
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(this.x - 1, this.y - 1, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }

  checkCollision(devil) {
    const dx = this.x - devil.x;
    const dy = this.y - devil.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    return dist < devil.size * 0.6 + this.size;
  }
}

// Spray drop projectile
class SprayDrop {
  constructor(tx, ty, angleOffset) {
    this.x = W / 2;
    this.y = H - 200;
    const dx = tx - this.x;
    const dy = ty - this.y;
    const baseAngle = Math.atan2(dy, dx) + angleOffset;
    const wp = weapons[2];
    const speedVariance = wp.speed * (0.8 + Math.random() * 0.4);
    this.vx = Math.cos(baseAngle) * speedVariance;
    this.vy = Math.sin(baseAngle) * speedVariance;
    this.life = 50 + Math.random() * 20;
    this.size = wp.size * (0.7 + Math.random() * 0.6);
    this.damage = wp.damage;
    this.alpha = 0.7 + Math.random() * 0.3;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.08;
    this.life--;
    this.alpha *= 0.995;
    return this.life > 0 && this.x > -20 && this.x < W + 20 && this.y > -20 && this.y < H + 20;
  }

  draw() {
    ctx.globalAlpha = this.alpha * (this.life > 15 ? 1 : this.life / 15);
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fillStyle = '#a0d8ef';
    ctx.shadowColor = '#c0e8ff';
    ctx.shadowBlur = 4;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  }

  checkCollision(devil) {
    const dx = this.x - devil.x;
    const dy = this.y - devil.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    return dist < devil.size * 0.55 + this.size;
  }
}

// Angel class
class Angel {
  constructor() {
    this.size = 28;
    this.speed = 0.6 + Math.random() * 0.3;

    // Spawn from left or right
    if (Math.random() < 0.5) {
      this.x = -this.size;
    } else {
      this.x = W + this.size;
    }
    this.y = H * 0.2 + Math.random() * H * 0.3;

    this.targetX = W / 2 + (Math.random() - 0.5) * 100;
    this.targetY = H - 300 + Math.random() * 40;
    this.alive = true;
    this.reachedChurch = false;
    this.deathTimer = 0;
    this.deathType = ''; // 'saved' or 'caught'
    this.wingAngle = 0;
    this.wobble = Math.random() * Math.PI * 2;
    this.glowPhase = Math.random() * Math.PI * 2;
    this.haloGlow = 0;
  }

  update() {
    if (!this.alive) {
      this.deathTimer++;
      if (this.deathType === 'saved') {
        this.y -= 2;
      } else {
        this.y += 1;
        this.x += (Math.random() - 0.5) * 2;
      }
      return this.deathTimer < 50;
    }

    this.wobble += 0.04;
    this.wingAngle = Math.sin(this.wobble * 2.5) * 0.6;
    this.glowPhase += 0.05;
    this.haloGlow = 0.5 + Math.sin(this.glowPhase) * 0.3;

    const dx = this.targetX - this.x + Math.sin(this.wobble) * 20;
    const dy = this.targetY - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > 10) {
      this.x += (dx / dist) * this.speed;
      this.y += (dy / dist) * this.speed;
    } else {
      // Reached church - grant life!
      this.alive = false;
      this.deathType = 'saved';
      this.reachedChurch = true;
      if (lives < 5) {
        lives++;
        updateLives();
      }
      // Heavenly particle burst
      for (let i = 0; i < 20; i++) {
        particles.push({
          x: this.x, y: this.y,
          vx: (Math.random() - 0.5) * 5,
          vy: -Math.random() * 4 - 1,
          life: 40 + Math.random() * 30,
          maxLife: 70,
          color: `hsl(${45 + Math.random() * 20}, 100%, ${70 + Math.random() * 20}%)`,
          size: 2 + Math.random() * 3
        });
      }
      return true;
    }
    return true;
  }

  draw() {
    const s = this.size;
    const alpha = this.alive ? 1 : Math.max(0, 1 - this.deathTimer / 50);

    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.globalAlpha = alpha;

    // Outer holy glow
    const glowR = s * 1.5 + Math.sin(this.glowPhase) * 5;
    const outerGlow = ctx.createRadialGradient(0, -s * 0.2, 0, 0, -s * 0.2, glowR);
    outerGlow.addColorStop(0, `rgba(255,255,200,${this.haloGlow * 0.2})`);
    outerGlow.addColorStop(0.5, `rgba(255,230,150,${this.haloGlow * 0.1})`);
    outerGlow.addColorStop(1, 'rgba(255,230,150,0)');
    ctx.fillStyle = outerGlow;
    ctx.beginPath();
    ctx.arc(0, -s * 0.2, glowR, 0, Math.PI * 2);
    ctx.fill();

    // Wings
    ctx.fillStyle = 'rgba(255,255,240,0.6)';
    // Left wing
    ctx.save();
    ctx.rotate(-0.2 + this.wingAngle);
    ctx.beginPath();
    ctx.moveTo(-3, -3);
    ctx.quadraticCurveTo(-s * 1.4, -s * 1.0, -s * 0.6, 5);
    ctx.quadraticCurveTo(-s * 0.3, -3, -3, 0);
    ctx.fill();
    // Wing feather lines
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 0.5;
    for (let f = 0; f < 4; f++) {
      const t = (f + 1) / 5;
      ctx.beginPath();
      ctx.moveTo(-3 - t * (s * 1.1), -3 + t * (-s * 0.7) + (1 - t) * 8);
      ctx.lineTo(-3 - t * (s * 0.8), 5 - t * 2);
      ctx.stroke();
    }
    ctx.restore();
    // Right wing
    ctx.save();
    ctx.rotate(0.2 - this.wingAngle);
    ctx.beginPath();
    ctx.moveTo(3, -3);
    ctx.quadraticCurveTo(s * 1.4, -s * 1.0, s * 0.6, 5);
    ctx.quadraticCurveTo(s * 0.3, -3, 3, 0);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 0.5;
    for (let f = 0; f < 4; f++) {
      const t = (f + 1) / 5;
      ctx.beginPath();
      ctx.moveTo(3 + t * (s * 1.1), -3 + t * (-s * 0.7) + (1 - t) * 8);
      ctx.lineTo(3 + t * (s * 0.8), 5 - t * 2);
      ctx.stroke();
    }
    ctx.restore();

    // Body (white robe)
    const robeGrd = ctx.createLinearGradient(0, -s * 0.2, 0, s * 0.6);
    robeGrd.addColorStop(0, '#fff');
    robeGrd.addColorStop(1, '#ddd');
    ctx.fillStyle = robeGrd;
    ctx.beginPath();
    ctx.ellipse(0, s * 0.1, s * 0.3, s * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head
    ctx.fillStyle = '#ffe8cc';
    ctx.beginPath();
    ctx.arc(0, -s * 0.4, s * 0.22, 0, Math.PI * 2);
    ctx.fill();

    // Eyes (gentle, closed)
    ctx.strokeStyle = '#886644';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(-s * 0.08, -s * 0.42, 3, 0.2, Math.PI - 0.2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(s * 0.08, -s * 0.42, 3, 0.2, Math.PI - 0.2);
    ctx.stroke();

    // Gentle smile
    ctx.strokeStyle = '#aa7755';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0, -s * 0.33, 4, 0.3, Math.PI - 0.3);
    ctx.stroke();

    // Halo
    ctx.strokeStyle = `rgba(255,215,0,${0.6 + this.haloGlow * 0.4})`;
    ctx.shadowColor = '#ffd700';
    ctx.shadowBlur = 8 + Math.sin(this.glowPhase) * 4;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(0, -s * 0.65, s * 0.2, s * 0.06, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Death effects
    if (!this.alive && this.deathType === 'caught') {
      // Fading red X
      ctx.strokeStyle = `rgba(255,80,80,${alpha})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-12, -12); ctx.lineTo(12, 12);
      ctx.moveTo(12, -12); ctx.lineTo(-12, 12);
      ctx.stroke();
    }

    ctx.globalAlpha = 1;
    ctx.restore();
  }
}

function updateLives() {
  let hearts = '';
  for (let i = 0; i < lives; i++) hearts += '\u2764 ';
  for (let i = lives; i < 5; i++) hearts += '\u2661 ';
  document.getElementById('livesDisplay').textContent = hearts;
}

function updateScore() {
  document.getElementById('scoreDisplay').textContent = 'Skore: ' + score;
}

function updateWave() {
  document.getElementById('waveDisplay').textContent = 'Vlna: ' + wave + '/' + totalWaves;
}

// Weapon HUD drawing
function drawWeaponHUD() {
  const hudX = 20;
  const hudY = H - 90;
  const slotW = 60;
  const slotH = 50;
  const gap = 8;

  for (let i = 0; i < weapons.length; i++) {
    const sx = hudX + i * (slotW + gap);
    const sy = hudY;
    const isActive = i === currentWeapon;

    // Slot background
    ctx.fillStyle = isActive ? 'rgba(255,215,0,0.25)' : 'rgba(0,0,0,0.5)';
    ctx.strokeStyle = isActive ? '#ffd700' : '#555';
    ctx.lineWidth = isActive ? 2.5 : 1.5;
    ctx.beginPath();
    ctx.roundRect(sx, sy, slotW, slotH, 6);
    ctx.fill();
    ctx.stroke();

    // Active glow
    if (isActive && weaponSwitchTimer > 0) {
      ctx.strokeStyle = `rgba(255,215,0,${weaponSwitchTimer / 30 * 0.6})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.roundRect(sx - 2, sy - 2, slotW + 4, slotH + 4, 8);
      ctx.stroke();
    }

    // Weapon icon
    ctx.save();
    ctx.translate(sx + slotW / 2, sy + slotH / 2 - 4);
    if (i === 0) {
      // Holy water drop icon
      ctx.fillStyle = isActive ? '#7ec8f0' : '#5a8aa0';
      ctx.beginPath();
      ctx.moveTo(0, -12);
      ctx.quadraticCurveTo(12, 6, 0, 14);
      ctx.quadraticCurveTo(-12, 6, 0, -12);
      ctx.fill();
      // Cross on drop
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(0, -2); ctx.lineTo(0, 8);
      ctx.moveTo(-4, 2); ctx.lineTo(4, 2);
      ctx.stroke();
    } else if (i === 1) {
      // Pistol icon
      ctx.fillStyle = isActive ? '#b0e0ff' : '#6a8a9a';
      // Barrel
      ctx.fillRect(-12, -4, 18, 6);
      // Grip
      ctx.fillRect(-2, 2, 8, 12);
      // Trigger guard
      ctx.strokeStyle = isActive ? '#b0e0ff' : '#6a8a9a';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(2, 6, 4, 0, Math.PI);
      ctx.stroke();
      // Muzzle flash hint
      if (isActive) {
        ctx.fillStyle = 'rgba(180,230,255,0.4)';
        ctx.beginPath();
        ctx.arc(8, -1, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if (i === 2) {
      // Spray icon - bottle with spray lines
      const col = isActive ? '#a0d8ef' : '#6a8a9a';
      ctx.fillStyle = col;
      // Bottle body
      ctx.fillRect(-5, -2, 10, 14);
      // Bottle neck
      ctx.fillRect(-3, -6, 6, 5);
      // Nozzle
      ctx.fillRect(-6, -8, 12, 3);
      // Spray lines
      ctx.strokeStyle = isActive ? 'rgba(160,216,239,0.7)' : 'rgba(106,138,154,0.5)';
      ctx.lineWidth = 1;
      for (let s = -2; s <= 2; s++) {
        const ang = s * 0.2;
        ctx.beginPath();
        ctx.moveTo(0, -9);
        ctx.lineTo(Math.sin(ang) * 12, -9 - Math.cos(ang) * 10);
        ctx.stroke();
      }
      // Spray dots
      if (isActive) {
        ctx.fillStyle = 'rgba(160,216,239,0.5)';
        for (let s = 0; s < 5; s++) {
          const da = (Math.random() - 0.5) * 0.5;
          const dd = 8 + Math.random() * 6;
          ctx.beginPath();
          ctx.arc(Math.sin(da) * dd, -9 - Math.cos(da) * dd, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    } else if (i === 3) {
      // Beam icon - vertical beam with waves
      const col = isActive ? '#50c8ff' : '#3a7a9a';
      // Beam line (thick vertical)
      ctx.strokeStyle = col;
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(0, 12); ctx.lineTo(0, -10);
      ctx.stroke();
      // Glow
      if (isActive) {
        ctx.strokeStyle = 'rgba(80,200,255,0.3)';
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.moveTo(0, 12); ctx.lineTo(0, -10);
        ctx.stroke();
      }
      // Side waves
      ctx.strokeStyle = isActive ? 'rgba(80,200,255,0.6)' : 'rgba(58,122,154,0.4)';
      ctx.lineWidth = 1;
      for (let s = -1; s <= 1; s += 2) {
        ctx.beginPath();
        ctx.moveTo(s * 4, 8);
        ctx.quadraticCurveTo(s * 8, 0, s * 4, -8);
        ctx.stroke();
      }
      // Cross at top
      ctx.strokeStyle = col;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(-4, -10); ctx.lineTo(4, -10);
      ctx.stroke();
    }
    ctx.restore();

    // Key number
    ctx.fillStyle = isActive ? '#ffd700' : '#888';
    ctx.font = 'bold 11px Segoe UI, Arial';
    ctx.textAlign = 'center';
    ctx.fillText(weapons[i].key, sx + slotW / 2, sy + slotH - 3);

    // Info above slot
    ctx.font = '9px Segoe UI, Arial';
    if (i === 0 || i === 2 || i === 3) {
      // Water cost
      ctx.fillStyle = isActive ? '#aadcf0' : '#667';
      const costLabel = i === 3 ? weapons[i].waterCost + '%/s' : weapons[i].waterCost + '%';
      ctx.fillText(costLabel, sx + slotW / 2, sy - 4);
    } else if (i === 1) {
      // Ammo count for pistol
      if (pistolReloading) {
        ctx.fillStyle = '#ffaa00';
        ctx.fillText('R: ' + pistolReloadWaterCost + '%', sx + slotW / 2, sy - 4);
      } else if (pistolAmmo === 0) {
        ctx.fillStyle = '#ff4444';
        ctx.fillText('[R] dobit', sx + slotW / 2, sy - 4);
      } else {
        ctx.fillStyle = isActive ? '#aadcf0' : '#667';
        ctx.fillText(pistolAmmo + '/' + pistolMagMax, sx + slotW / 2, sy - 4);
      }
    }
    ctx.textAlign = 'start';

    // Pistol reload progress bar overlay
    if (i === 1 && pistolReloading) {
      const reloadProgress = pistolReloadTimer / pistolReloadTime;
      // Dark overlay
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.beginPath();
      ctx.roundRect(sx, sy, slotW, slotH, 6);
      ctx.fill();
      // Progress bar
      ctx.fillStyle = '#ffaa00';
      ctx.fillRect(sx + 4, sy + slotH - 8, (slotW - 8) * reloadProgress, 4);
      ctx.fillStyle = '#553300';
      ctx.fillRect(sx + 4, sy + slotH - 8, slotW - 8, 4);
      ctx.fillStyle = '#ffaa00';
      ctx.fillRect(sx + 4, sy + slotH - 8, (slotW - 8) * reloadProgress, 4);
    }

    // Pistol empty ammo indicator - red border flash
    if (i === 1 && pistolAmmo === 0 && !pistolReloading && isActive) {
      const flashAlpha = 0.3 + Math.sin(waterFlashTimer * 3) * 0.3;
      ctx.strokeStyle = `rgba(255,50,50,${flashAlpha})`;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.roundRect(sx, sy, slotW, slotH, 6);
      ctx.stroke();
    }
  }

  if (weaponSwitchTimer > 0) weaponSwitchTimer--;
}

// Wave banner drawing
function drawWaveBanner() {
  if (waveBannerTimer <= 0) return;

  const progress = waveBannerTimer / waveBannerDuration;
  // Slide in and fade out
  let alpha, yOff;
  if (progress > 0.8) {
    // Slide in (first 20%)
    const t = (1 - progress) / 0.2;
    alpha = t;
    yOff = (1 - t) * -30;
  } else if (progress < 0.2) {
    // Fade out (last 20%)
    alpha = progress / 0.2;
    yOff = 0;
  } else {
    alpha = 1;
    yOff = 0;
  }

  const cy = H * 0.28 + yOff;
  ctx.save();
  ctx.globalAlpha = alpha;

  // Dark backdrop
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, cy - 30, W, 60);

  // Colored line top/bottom
  const lineColor = wave >= 8 ? '#ff4444' : wave >= 5 ? '#ff8800' : '#ffd700';
  ctx.fillStyle = lineColor;
  ctx.fillRect(0, cy - 30, W, 2);
  ctx.fillRect(0, cy + 28, W, 2);

  // Wave text
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Wave number
  ctx.font = 'bold 28px Segoe UI, Arial';
  ctx.fillStyle = lineColor;
  ctx.shadowColor = lineColor;
  ctx.shadowBlur = 10;
  ctx.fillText(waveBanner, W / 2, cy);
  ctx.shadowBlur = 0;

  ctx.globalAlpha = 1;
  ctx.textAlign = 'start';
  ctx.restore();
}

// Water tank drawing
function drawWaterTank() {
  const barW = 300;
  const barH = 28;
  const barX = (W - barW) / 2;
  const barY = H - 38;
  const fill = water / waterMax;
  const isLow = water < weapons[currentWeapon].waterCost;

  // Tank background (stone look)
  ctx.fillStyle = '#2a2a2a';
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 2;
  // Rounded rect
  const r = 6;
  ctx.beginPath();
  ctx.moveTo(barX + r, barY);
  ctx.lineTo(barX + barW - r, barY);
  ctx.quadraticCurveTo(barX + barW, barY, barX + barW, barY + r);
  ctx.lineTo(barX + barW, barY + barH - r);
  ctx.quadraticCurveTo(barX + barW, barY + barH, barX + barW - r, barY + barH);
  ctx.lineTo(barX + r, barY + barH);
  ctx.quadraticCurveTo(barX, barY + barH, barX, barY + barH - r);
  ctx.lineTo(barX, barY + r);
  ctx.quadraticCurveTo(barX, barY, barX + r, barY);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Water fill with wave animation
  const fillW = (barW - 4) * fill;
  if (fillW > 0) {
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(barX + 2 + r, barY + 2);
    ctx.lineTo(barX + 2 + fillW - (fillW > r ? 0 : 0), barY + 2);
    ctx.lineTo(barX + 2 + fillW, barY + barH - 2);
    ctx.lineTo(barX + 2, barY + barH - 2);
    ctx.closePath();
    ctx.clip();

    // Water gradient
    const wGrd = ctx.createLinearGradient(barX, barY, barX, barY + barH);
    if (isLow && Math.sin(waterFlashTimer) > 0) {
      wGrd.addColorStop(0, 'rgba(255,80,80,0.9)');
      wGrd.addColorStop(1, 'rgba(180,40,40,0.9)');
    } else {
      wGrd.addColorStop(0, 'rgba(120,200,240,0.9)');
      wGrd.addColorStop(0.5, 'rgba(80,160,220,0.9)');
      wGrd.addColorStop(1, 'rgba(50,120,200,0.9)');
    }
    ctx.fillStyle = wGrd;
    ctx.fillRect(barX + 2, barY + 2, fillW, barH - 4);

    // Animated wave on top of water
    ctx.beginPath();
    ctx.moveTo(barX + 2, barY + 2);
    for (let wx = 0; wx <= fillW; wx += 2) {
      const waveY = Math.sin((wx * 0.05) + crossGlow * 3) * 2;
      ctx.lineTo(barX + 2 + wx, barY + 4 + waveY);
    }
    ctx.lineTo(barX + 2 + fillW, barY + 2);
    ctx.closePath();
    ctx.fillStyle = 'rgba(180,230,255,0.4)';
    ctx.fill();

    // Shine highlight
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(barX + 4, barY + 4, fillW - 4, 6);

    ctx.restore();
  }

  // Border overlay
  ctx.strokeStyle = '#777';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(barX + r, barY);
  ctx.lineTo(barX + barW - r, barY);
  ctx.quadraticCurveTo(barX + barW, barY, barX + barW, barY + r);
  ctx.lineTo(barX + barW, barY + barH - r);
  ctx.quadraticCurveTo(barX + barW, barY + barH, barX + barW - r, barY + barH);
  ctx.lineTo(barX + r, barY + barH);
  ctx.quadraticCurveTo(barX, barY + barH, barX, barY + barH - r);
  ctx.lineTo(barX, barY + r);
  ctx.quadraticCurveTo(barX, barY, barX + r, barY);
  ctx.closePath();
  ctx.stroke();

  // Cross icon on left
  ctx.strokeStyle = '#ffd700';
  ctx.lineWidth = 2;
  const ix = barX - 20;
  const iy = barY + barH / 2;
  ctx.beginPath();
  ctx.moveTo(ix, iy - 8); ctx.lineTo(ix, iy + 8);
  ctx.moveTo(ix - 5, iy - 2); ctx.lineTo(ix + 5, iy - 2);
  ctx.stroke();

  // Drop icon on right
  ctx.fillStyle = '#7ec8f0';
  ctx.beginPath();
  ctx.moveTo(barX + barW + 15, barY + 6);
  ctx.quadraticCurveTo(barX + barW + 22, barY + barH - 4, barX + barW + 15, barY + barH - 2);
  ctx.quadraticCurveTo(barX + barW + 8, barY + barH - 4, barX + barW + 15, barY + 6);
  ctx.fill();

  // Percentage text
  ctx.fillStyle = isLow ? '#ff6666' : '#fff';
  ctx.font = 'bold 13px Segoe UI, Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(Math.round(water) + '%', barX + barW / 2, barY + barH / 2 + 1);
  ctx.textAlign = 'start';

  waterFlashTimer += 0.15;
}

// ============ INPUT SYSTEM ============
// Pointer Lock for raw mouse (bypasses OS keyboard-mouse throttling)
let pointerLocked = false;

function lockPointer() {
  if (!pointerLocked) canvas.requestPointerLock();
}

document.addEventListener('pointerlockchange', () => {
  pointerLocked = document.pointerLockElement === canvas;
});

// Mouse movement accumulator - collects deltas between frames
let moveDeltaX = 0;
let moveDeltaY = 0;

document.addEventListener('mousemove', (e) => {
  if (pointerLocked) {
    moveDeltaX += e.movementX;
    moveDeltaY += e.movementY;
  } else {
    mouseX = e.clientX;
    mouseY = e.clientY;
  }
});

// Apply accumulated mouse deltas once per frame (called in game loop)
function applyMouseDeltas() {
  if (pointerLocked) {
    mouseX = Math.max(0, Math.min(W, mouseX + moveDeltaX));
    mouseY = Math.max(0, Math.min(H, mouseY + moveDeltaY));
  }
  moveDeltaX = 0;
  moveDeltaY = 0;
}

// Keyboard - just track state, nothing else
document.addEventListener('keydown', (e) => {
  if (e.key === ' ') e.preventDefault();
  if (e.repeat) return;
  const k = e.key.toLowerCase();
  keysJustPressed[k] = true;
  keysDown[k] = true;
});
document.addEventListener('keyup', (e) => {
  if (e.key === ' ') e.preventDefault();
  keysDown[e.key.toLowerCase()] = false;
});

// Shoot
function shoot() {
  if (!gameRunning) return;
  if (currentWeapon === 0) {
    if (water < weapons[0].waterCost) { waterFlashTimer = 0; return; }
    water -= weapons[0].waterCost;
    holyWaters.push(new HolyWater(W / 2, H - 200, mouseX, mouseY));
  } else if (currentWeapon === 1) {
    if (pistolReloading) return;
    if (pistolAmmo <= 0) { weaponSwitchTimer = 15; return; }
    pistolAmmo--;
    pistolBullets.push(new PistolBullet(mouseX, mouseY));
  } else if (currentWeapon === 2) {
    const wp = weapons[2];
    if (water < wp.waterCost) { waterFlashTimer = 0; return; }
    water -= wp.waterCost;
    const spreadRad = (wp.spreadAngle / 2) * (Math.PI / 180);
    for (let d = 0; d < wp.dropCount; d++) {
      sprayDrops.push(new SprayDrop(mouseX, mouseY, (Math.random() * 2 - 1) * spreadRad));
    }
  }
}

// Process all input once per frame
function processInput() {
  applyMouseDeltas();
  if (keysJustPressed['q']) { currentWeapon = 0; weaponSwitchTimer = 30; beamActive = false; }
  if (keysJustPressed['w']) { currentWeapon = 1; weaponSwitchTimer = 30; beamActive = false; }
  if (keysJustPressed['e']) { currentWeapon = 2; weaponSwitchTimer = 30; beamActive = false; }
  if (keysJustPressed['f']) { currentWeapon = 3; weaponSwitchTimer = 30; beamActive = false; }
  // Non-beam weapons: shoot on press
  if (keysJustPressed[' '] && currentWeapon !== 3) shoot();
  // Beam weapon: activate/deactivate on hold
  if (currentWeapon === 3) {
    const holding = mouseHeld || keysDown[' '];
    if (holding && water > 0) {
      if (!beamActive) {
        beamActive = true;
        beamDamageTimer = 0;
        beamWaterTimer = 0;
      }
    } else {
      beamActive = false;
    }
  } else {
    beamActive = false;
  }
  // Reload pistol
  if (keysJustPressed['r'] && currentWeapon === 1 && !pistolReloading && pistolAmmo < pistolMagMax) {
    if (water >= pistolReloadWaterCost) {
      pistolReloading = true;
      pistolReloadTimer = 0;
      water -= pistolReloadWaterCost;
    } else { waterFlashTimer = 0; }
  }
  for (const k in keysJustPressed) delete keysJustPressed[k];
}

// Mouse click to shoot + lock pointer + track held state
document.addEventListener('mousedown', (e) => {
  if (e.button === 0) {
    mouseHeld = true;
    if (gameRunning) {
      if (!pointerLocked) lockPointer();
      if (currentWeapon !== 3) shoot(); // beam handled in processInput
    }
  }
});
document.addEventListener('mouseup', (e) => {
  if (e.button === 0) mouseHeld = false;
});

// Mouse wheel to switch weapons
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  beamActive = false;
  currentWeapon = e.deltaY > 0
    ? (currentWeapon + 1) % weapons.length
    : (currentWeapon - 1 + weapons.length) % weapons.length;
  weaponSwitchTimer = 30;
}, { passive: false });

// Main game loop
function gameLoop() {
  if (!gameRunning) return;

  // Process keyboard input
  processInput();

  // Screen shake
  ctx.save();
  if (shakeTimer > 0) {
    shakeTimer--;
    const sx = (Math.random() - 0.5) * shakeIntensity;
    const sy = (Math.random() - 0.5) * shakeIntensity;
    ctx.translate(sx, sy);
    shakeIntensity *= 0.9;
  }

  // Draw scene
  drawSky();
  drawChurch();

  // Refill water
  if (water < waterMax) {
    water = Math.min(waterMax, water + waterRefillRate);
  }

  // Pistol reload tick
  if (pistolReloading) {
    pistolReloadTimer++;
    if (pistolReloadTimer >= pistolReloadTime) {
      pistolReloading = false;
      pistolAmmo = pistolMagMax;
    }
  }

  // Get current wave config
  const wc = waveConfig[Math.min(wave - 1, totalWaves - 1)];

  // Spawn devils (use wave config)
  if (devilsSpawnedInWave < wc.count) {
    spawnTimer++;
    if (spawnTimer >= wc.spawnInterval) {
      spawnTimer = 0;
      devils.push(new Devil());
      devilsSpawnedInWave++;
    }
  }

  // Check wave completion - wave ends when all devils spawned and none alive remain
  // (devils can be killed OR reach the church - either way the wave advances)
  // Angels on screen do NOT block wave transitions
  const allSpawned = devilsSpawnedInWave >= wc.count;
  const noLivingDevils = devils.filter(d => d.alive).length === 0;
  if (allSpawned && noLivingDevils) {
    if (wave >= totalWaves) {
      // Victory!
      gameWon = true;
      gameRunning = false;
      if (pointerLocked) document.exitPointerLock();
      document.getElementById('finalScore').textContent = 'Skore: ' + score;
      const titleEl = document.getElementById('gameOverTitle');
      titleEl.textContent = 'Vitezstvi!';
      titleEl.classList.add('victory');
      document.getElementById('gameOverText').textContent = 'Kostel je zachranen! Vsech 10 vln certu porazeno!';
      document.getElementById('gameOverScreen').style.display = 'flex';
      return;
    }

    wave++;
    devilsKilledInWave = 0;
    devilsSpawnedInWave = 0;
    spawnTimer = 0;
    updateWave();

    // Show wave banner
    const nextWc = waveConfig[wave - 1];
    waveBanner = 'Vlna ' + wave + '/' + totalWaves + ': ' + nextWc.name;
    waveBannerTimer = waveBannerDuration;

    // Wave announcement particle burst
    for (let i = 0; i < 20; i++) {
      particles.push({
        x: W / 2, y: H / 2,
        vx: (Math.random() - 0.5) * 10,
        vy: (Math.random() - 0.5) * 10,
        life: 40 + Math.random() * 20,
        maxLife: 60,
        color: wave >= 8 ? '#ff4444' : '#ffd700',
        size: 3 + Math.random() * 4
      });
    }
  }

  // Wave banner timer
  if (waveBannerTimer > 0) waveBannerTimer--;

  // Angel spawn logic - lower lives = higher chance
  if (angelSpawnCooldown > 0) {
    angelSpawnCooldown--;
  } else if (angels.filter(a => a.alive).length === 0) {
    // Chance scales with missing lives: 0 lives missing = 0.05%, 4 missing = 1.2% per frame
    const missingLives = 5 - lives;
    const spawnChance = 0.0005 + missingLives * 0.003;
    if (Math.random() < spawnChance && lives < 5) {
      angels.push(new Angel());
      angelSpawnCooldown = angelSpawnCooldownMax;
    }
  }

  // Update angels and check devil collisions
  for (let i = angels.length - 1; i >= 0; i--) {
    const angel = angels[i];
    if (!angel.update()) {
      angels.splice(i, 1);
      continue;
    }
    // Check if any devil touches the angel
    if (angel.alive) {
      for (let j = devils.length - 1; j >= 0; j--) {
        if (!devils[j].alive) continue;
        const dx = angel.x - devils[j].x;
        const dy = angel.y - devils[j].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < angel.size * 0.5 + devils[j].size * 0.5) {
          // Devil caught the angel!
          angel.alive = false;
          angel.deathType = 'caught';
          // Dark burst particles
          for (let p = 0; p < 10; p++) {
            particles.push({
              x: angel.x, y: angel.y,
              vx: (Math.random() - 0.5) * 4,
              vy: (Math.random() - 0.5) * 4,
              life: 20 + Math.random() * 15,
              maxLife: 35,
              color: '#666',
              size: 2 + Math.random() * 2
            });
          }
          break;
        }
      }
    }
  }

  // Devils chase nearby angel (divert some towards angel)
  const livingAngel = angels.find(a => a.alive);
  if (livingAngel) {
    devils.forEach(d => {
      if (!d.alive) return;
      const dx = livingAngel.x - d.x;
      const dy = livingAngel.y - d.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      // Devils within range chase the angel
      if (dist < 250) {
        d.x += (dx / dist) * d.speed * 0.4;
        d.y += (dy / dist) * d.speed * 0.4;
      }
    });
  }

  // Update and draw holy water
  for (let i = holyWaters.length - 1; i >= 0; i--) {
    const hw = holyWaters[i];
    if (!hw.update()) {
      holyWaters.splice(i, 1);
      continue;
    }

    // Check collisions
    for (let j = devils.length - 1; j >= 0; j--) {
      if (devils[j].alive && hw.checkCollision(devils[j])) {
        splashes.push(new Splash(hw.x, hw.y));
        devils[j].hit();
        holyWaters.splice(i, 1);
        updateScore();
        break;
      }
    }
  }

  // Update and check pistol bullets
  for (let i = pistolBullets.length - 1; i >= 0; i--) {
    const pb = pistolBullets[i];
    if (!pb.update()) {
      pistolBullets.splice(i, 1);
      continue;
    }
    for (let j = devils.length - 1; j >= 0; j--) {
      if (devils[j].alive && pb.checkCollision(devils[j])) {
        // Small splash for pistol
        splashes.push(new Splash(pb.x, pb.y));
        devils[j].hit(pb.damage);
        pistolBullets.splice(i, 1);
        updateScore();
        break;
      }
    }
  }

  // Update and check spray drops
  for (let i = sprayDrops.length - 1; i >= 0; i--) {
    const sd = sprayDrops[i];
    if (!sd.update()) {
      sprayDrops.splice(i, 1);
      continue;
    }
    for (let j = devils.length - 1; j >= 0; j--) {
      if (devils[j].alive && sd.checkCollision(devils[j])) {
        devils[j].hit(sd.damage);
        // Small particles instead of full splash
        particles.push({
          x: sd.x, y: sd.y,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 0.5) * 3,
          life: 10 + Math.random() * 10,
          maxLife: 20,
          color: '#a0d8ef',
          size: 2 + Math.random() * 2
        });
        sprayDrops.splice(i, 1);
        updateScore();
        break;
      }
    }
  }

  // ======== BEAM WEAPON UPDATE ========
  if (beamActive && currentWeapon === 3) {
    beamPhase += 0.15;
    // Water drain: 20% per second = every 60 frames
    beamWaterTimer++;
    if (beamWaterTimer >= beamWaterInterval) {
      beamWaterTimer = 0;
      water -= weapons[3].waterCost;
      if (water <= 0) {
        water = 0;
        beamActive = false;
      }
    }
    // Damage: hit devils every 1s (60 frames)
    beamDamageTimer++;
    const doDamage = beamDamageTimer >= beamDamageInterval;
    if (doDamage) beamDamageTimer = 0;

    // Beam line from church to cursor
    const bx1 = W / 2, by1 = H - 200;
    const bx2 = mouseX, by2 = mouseY;
    const bdx = bx2 - bx1, bdy = by2 - by1;
    const bLen = Math.sqrt(bdx * bdx + bdy * bdy);
    if (bLen > 0) {
      // Perpendicular direction for width check
      const perpX = -bdy / bLen, perpY = bdx / bLen;
      const halfW = weapons[3].beamWidth / 2;

      // Check collision with all living devils (beam pierces through)
      devils.forEach(d => {
        if (!d.alive) return;
        // Project devil position onto beam line
        const dx = d.x - bx1, dy = d.y - by1;
        const proj = (dx * bdx + dy * bdy) / (bLen * bLen);
        if (proj < 0 || proj > 1) return; // outside beam segment
        // Distance from devil center to beam line
        const closestX = bx1 + proj * bdx;
        const closestY = by1 + proj * bdy;
        const distToBeam = Math.sqrt((d.x - closestX) ** 2 + (d.y - closestY) ** 2);
        if (distToBeam < halfW + d.size * 0.4) {
          // Devil is touching the beam
          d.flashTimer = 3;
          if (doDamage) {
            d.hit(weapons[3].damage);
            updateScore();
            // Water particles on hit
            for (let p = 0; p < 4; p++) {
              particles.push({
                x: d.x, y: d.y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 15 + Math.random() * 10,
                maxLife: 25,
                color: '#50c8ff',
                size: 2 + Math.random() * 3
              });
            }
          }
        }
      });
    }
  }

  // Update devils
  for (let i = devils.length - 1; i >= 0; i--) {
    if (!devils[i].update()) {
      if (devils[i].alive) {
        // Devil reached church
        shakeTimer = 20;
        shakeIntensity = 10;
      }
      devils.splice(i, 1);
    }
  }

  // Draw beam (behind devils for glow effect, main beam in front)
  if (beamActive && currentWeapon === 3) {
    const bx1 = W / 2, by1 = H - 200;
    const bx2 = mouseX, by2 = mouseY;
    const bdx = bx2 - bx1, bdy = by2 - by1;
    const bLen = Math.sqrt(bdx * bdx + bdy * bdy);
    if (bLen > 1) {
      const bw = weapons[3].beamWidth;
      const pulse = 1 + Math.sin(beamPhase * 3) * 0.15;

      // Outer glow (wide, faint)
      ctx.save();
      ctx.globalAlpha = 0.15 + Math.sin(beamPhase * 2) * 0.05;
      ctx.strokeStyle = '#80d0ff';
      ctx.lineWidth = bw * 3 * pulse;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(bx1, by1);
      ctx.lineTo(bx2, by2);
      ctx.stroke();
      ctx.restore();

      // Middle glow
      ctx.save();
      ctx.globalAlpha = 0.4;
      ctx.strokeStyle = '#60c0ff';
      ctx.lineWidth = bw * 1.8 * pulse;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(bx1, by1);
      ctx.lineTo(bx2, by2);
      ctx.stroke();
      ctx.restore();

      // Core beam (bright)
      ctx.save();
      ctx.strokeStyle = '#c0eaff';
      ctx.shadowColor = '#50c8ff';
      ctx.shadowBlur = 15;
      ctx.lineWidth = bw * pulse;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(bx1, by1);
      ctx.lineTo(bx2, by2);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.restore();

      // Inner white core
      ctx.save();
      ctx.globalAlpha = 0.7 + Math.sin(beamPhase * 5) * 0.2;
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = bw * 0.3 * pulse;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(bx1, by1);
      ctx.lineTo(bx2, by2);
      ctx.stroke();
      ctx.restore();

      // Water spray particles along beam
      if (Math.random() < 0.6) {
        const t = Math.random();
        const px = bx1 + bdx * t;
        const py = by1 + bdy * t;
        const perpX = -bdy / bLen, perpY = bdx / bLen;
        const off = (Math.random() - 0.5) * bw * 1.5;
        particles.push({
          x: px + perpX * off, y: py + perpY * off,
          vx: perpX * (Math.random() - 0.5) * 3,
          vy: -Math.random() * 2 - 0.5,
          life: 8 + Math.random() * 8,
          maxLife: 16,
          color: Math.random() < 0.5 ? '#80d0ff' : '#c0eaff',
          size: 1.5 + Math.random() * 2
        });
      }

      // Impact splash at cursor
      ctx.save();
      const impactGlow = ctx.createRadialGradient(bx2, by2, 0, bx2, by2, bw * 2);
      impactGlow.addColorStop(0, 'rgba(200,240,255,0.5)');
      impactGlow.addColorStop(0.5, 'rgba(80,200,255,0.2)');
      impactGlow.addColorStop(1, 'rgba(80,200,255,0)');
      ctx.fillStyle = impactGlow;
      ctx.beginPath();
      ctx.arc(bx2, by2, bw * 2 * pulse, 0, Math.PI * 2);
      ctx.fill();
      // Cross at impact
      ctx.strokeStyle = `rgba(255,255,255,${0.4 + Math.sin(beamPhase * 4) * 0.2})`;
      ctx.lineWidth = 2;
      const cs = bw * 0.8;
      ctx.beginPath();
      ctx.moveTo(bx2, by2 - cs); ctx.lineTo(bx2, by2 + cs);
      ctx.moveTo(bx2 - cs, by2); ctx.lineTo(bx2 + cs, by2);
      ctx.stroke();
      ctx.restore();
    }
  }

  // Draw devils
  devils.forEach(d => d.draw());

  // Draw angels
  angels.forEach(a => a.draw());

  // Draw holy water
  holyWaters.forEach(hw => hw.draw());

  // Draw pistol bullets
  pistolBullets.forEach(pb => pb.draw());

  // Draw spray drops
  sprayDrops.forEach(sd => sd.draw());

  // Draw and update splashes
  for (let i = splashes.length - 1; i >= 0; i--) {
    if (!splashes[i].update()) {
      splashes.splice(i, 1);
    } else {
      splashes[i].draw();
    }
  }

  // Update and draw particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1;
    p.life--;
    if (p.life <= 0) {
      particles.splice(i, 1);
    } else {
      const alpha = p.life / p.maxLife;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.globalAlpha = alpha;
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  ctx.restore(); // End shake

  // Draw HUD (outside shake so it stays stable)
  drawWaterTank();
  drawWeaponHUD();
  drawWaveBanner();

  // Draw custom crosshair cursor
  const cx = mouseX, cy = mouseY;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.shadowColor = '#7ec8f0';
  ctx.shadowBlur = 6;
  // Outer cross lines
  ctx.beginPath();
  ctx.moveTo(cx - 14, cy); ctx.lineTo(cx - 5, cy);
  ctx.moveTo(cx + 5, cy); ctx.lineTo(cx + 14, cy);
  ctx.moveTo(cx, cy - 14); ctx.lineTo(cx, cy - 5);
  ctx.moveTo(cx, cy + 5); ctx.lineTo(cx, cy + 14);
  ctx.stroke();
  // Center dot
  ctx.fillStyle = '#ffd700';
  ctx.beginPath();
  ctx.arc(cx, cy, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Check game over
  if (lives <= 0) {
    gameRunning = false;
    if (pointerLocked) document.exitPointerLock();
    document.getElementById('finalScore').textContent = 'Skore: ' + score + ' (Vlna ' + wave + '/' + totalWaves + ')';
    const titleEl2 = document.getElementById('gameOverTitle');
    titleEl2.textContent = 'Konec hry!';
    titleEl2.classList.remove('victory');
    document.getElementById('gameOverText').textContent = 'Certi ovladli kostel ve vlne ' + wave + '...';
    document.getElementById('gameOverScreen').style.display = 'flex';
    return;
  }

  updateLives();
  requestAnimationFrame(gameLoop);
}

// Start / Restart
function startGame() {
  score = 0; lives = 5; wave = 1; water = waterMax; currentWeapon = 0;
  gameWon = false;
  pistolAmmo = pistolMagMax; pistolReloading = false; pistolReloadTimer = 0;
  beamActive = false; beamDamageTimer = 0; beamWaterTimer = 0; beamPhase = 0; mouseHeld = false;
  angels = []; angelSpawnCooldown = 0;
  devils = []; holyWaters = []; splashes = []; particles = []; pistolBullets = []; sprayDrops = [];
  devilsKilledInWave = 0;
  spawnTimer = 0; devilsSpawnedInWave = 0;
  gameRunning = true;
  mouseX = W / 2; mouseY = H / 2;
  moveDeltaX = 0; moveDeltaY = 0;
  for (const k in keysDown) keysDown[k] = false;
  for (const k in keysJustPressed) delete keysJustPressed[k];
  lockPointer();
  // Show first wave banner
  waveBanner = 'Vlna 1/' + totalWaves + ': ' + waveConfig[0].name;
  waveBannerTimer = waveBannerDuration;
  updateScore(); updateWave(); updateLives();
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameOverScreen').style.display = 'none';
  requestAnimationFrame(gameLoop);
}

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', startGame);

// Initial draw
drawSky();
drawChurch();
</script>
</body>
</html>
